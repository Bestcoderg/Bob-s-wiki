# C++ 左值右值&右值引用

首先要理解一下将亡值：将亡值就是在这一行结束之后该值将被析构。最典型的将亡值就是匿名对象，如:Test()。

### C**++11 之前，有一些让人们蛋疼的地方。**

需求 1：需要转递引用来提高效率，那么我们函数定义是这样的`void foo(Test &t){...}`。

需求 2：现在我们想这样调用函数，`foo(Test())`。what？编译不过。稍微解释一下，将引用绑定到一个匿名对象，完全没有意义，因为它可能很快就不在了。访问一个不在的对象，是多么恐怖的事情。

我们又想出了其他的办法，重载函数`void foo(Test t){...}`。what？还编译不过。因为这样重载又二义性，编译器不知道你到底要调用哪个。

最后没辙了，我们只能放大招了，`void foo(const Test& t){...}`只能这样了。`const`不是只读的意思吗，怎么还可以这样用。对的`const`干的活比较多，`const Test& t{Test()};`这种用法就退化回`const Test t{Test()};`, 这两种写法都会创建一个新的对象，所以`const`干了一个不属于它的活，这样即保障了传引用的高效又可以传入匿名对象。

需求 3：但是我们又需要改变它的值，那好吧，我们只能用`const_cast<Test&>(t)`强转后来改变他的值。

**C++11 引入了右值引用来帮助const分担工作。现在完全可以用void foo(Test&& t)和void foo(Test& t)两个函数来区分传入值是否是将亡值，并且可以重载，无二义性。**

### 左值引用&右值引用

- **左值引用：**左值引用就是平时常用的引用形式，引用建一个变量存储指向对象的地址。
1. 不能将其绑定到要求 “**转换的表达式、字面值常量、返回右值的表达式**”
2. **返回左值的函数，连同赋值、下标、解引用和前置递增 / 递减运算符，都是返回左值的表达式**。我们可以将一个左值引用绑定到这类表达式的结果上
- **右值引用：**右值有一个很重要的性质：只能绑定到一个将要销毁的对象
1. 则与左值引用相反，我们可以将一个右值引用到上面所述的表达式上，但是不能将一个右值引用直接绑定到一个左值上
2. 返回**非引用类型的函数，连同算术、关系、位以及后置递增运算符，都生成右值**。我们可以将一个 const 的左值引用或一个右值引用绑定到这类表达式上

右值引用也可以看作起名，只是它起名的对象是一个将亡值。然后延续这个将亡值的生命，直到这个的右值的生命也结束了。

```csharp
int i = 42;
int &r = i;            //正确，r引用i
int &&rr = i;          //错误，不能将一个右值引用到左值上
int &r2 = i * 42;      //错误，i*42是一个右值
const int &r3 = i * 42;//正确，我们可以将一个const的引用绑定到一个右值上
int &&rr2 = i * 42;    //正确，将rr2绑定到乘法结果上(右值)
```

```csharp
int ret(int i) {
    return i * 2;
}//返回右值
int& ret2(int& i) {
    return i;
}//返回左值
 
int &r = ret(1);     //错误
int &&rr = ret(1);   //正确
 
int &r2 = ret2(1);   //正确
int &&rr2 = ret2(1); //错误
```

**左值持久、右值短暂**

- 左值一般是绑定到对象身上，因此左值是持久的
- 而右值要么绑定在字面值常量、要么绑定到表达式求值过程中创建的临时对象身上，因此：
    - **右值引用所引用的对象将要被销毁**
    - **该对象没有其他用户**
- 这两个特性意味着，使用**右值引用的代码可以自由地接管所引用的对象的资源**

### **变量是左值**

- **变量可以看做只有一个运算对象而没有运算符的表达式。因此不能将一个右值引用绑定到一个右值引用类型的变量上**
- 因此，C++11中引入了std::forward实现完美转发来解决右值引用变量为左值，没办法向下一个函数作为右值传递的问题

[C++ STL](C++%20STL%20c51250b94fd343bfa896af452205287e.md)

```csharp
int &&rr1 = 42;  //正确，42是字面值
int &&rr2 = rr1; //错误，表达式rr1是左值
```

### **标准库 move() 函数**

- 虽然不能将一个右值引用绑定到一个左值上，但是我们可以**显式地将一个左值转换成对应的右值引用类型**
- move 函数就是实现上面的功能，move 函数用来获得绑定到左值上的右值引用
- 关于 move 函数内部到底是怎么实现的，其实 std::move 函数并不 “移动”，它仅仅进行了类型转换。下面给出一个简化版本的 std::move:

```csharp
template <typename T>
typename remove_reference<T>::type&& move(T&& param)
{
    using ReturnType = typename remove_reference<T>::type&&;
    return static_cast<ReturnType>(param);
}
```

代码很短，但是估计很难懂。首先看一下函数的返回类型，remove_reference 在头文件中，remove_reference 有一个成员 type，是 T 去除引用后的类型，所以 remove_reference::type&& 一定是右值引用，对于返回类型为右值的函数其返回值是一个右值（准确地说是 xvalue）。所以，知道了 std::move 函数的返回值是一个右值。然后，我们看一下函数的参数，使用的是通用引用类型（&&），意味者其可以接收左值，也可以接收右值。但是不管怎么推导，ReturnType 的类型一定是右值引用，最后 std::move 函数只是简单地调用 static_cast 将参数转化为右值引用。