# C++ extern / extern “C”

## 内部链接&外部链接

首先，在一个程序的**链接阶段把不同编译单元产生的符号联系起来**，具有两种链接方式：内部(隐式)链接与外部(显式)链接。

如果一个符号名对于它的编译单元来说是局部的，并且在链接时不可能与其他编译单元中的同样的名称相冲突，那个这个符号就是内部链接。内部链接意味着对此符号的访问仅限于当前的编译单元中，对其他编译单元都是不可见的。

static 关键字作用在全局变量时，表示静态全局变量，但是它的作用域仅仅在当前文件内，在其他文件中即使使用 extern 声明也是无法使用的。const 与 static 的作用域类似。带有 static、const 关键字和枚举类型的链接是内部的。

具有内部链接的符号无法作用于当前文件外部，**要让其影响程序的其他部分，可以将其放在. h 文件中**。此时在所有包含此. h 文件的源文件都有自己的定义且互不影响(如static的工具函数必须定义在.h文件中)。

在一个多文件的程序中，如果一个符号在链接时可以和其他编译单元交互，那么这个名称就有外部链接。外部链接意味着该定义不仅仅局限在单个编译单元中。**它可以在. o 文件中产生外部符号。可以被其他编译单元访问用来解析它们未定义的符号。因此它们在整个程序中必须是唯一的，否则将会导致重复定义。**

### extern

我们前面提到了外部链接与内部链接，实际上extern就是对于外部链接的一种支持。

在了解extern之前首先要知道C++中得单定义规则。所谓的**单定义规则（One Definition Rule,ODR）是指变量只能有一次定义**。为了满足这种需求，c++提供了两种变量声明。一种是定义声明（defining declaration）简称定义，它给变量分配内存空间；另外一种是引用声明（referencing declaration）简称为声明，它不给变量分配空间，因为它引用已有变量。

C++语言支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。为了将程序分为许多文件，则需要在文件中共享代码，例如一个文件的代码可能需要另一个文件中中定义的变量。

为了支持分离式编译，C++允许将声明和定义分离开来。变量的声明规定了变量的类型和名字，即使一个名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。定义则负责创建与名字关联的实体，定义还申请存储空间。

如果想声明一个变量而非定义它，就在变量名前添加extern关键字，而且不要显式地初始化变量：

```cpp
//file01.cpp
int cats = 22;
int dogs = 20;
int fleas;

//file02.cpp
#include <iostream>
#include <iostream>
#include "file01.cpp"
extern int cats;
int dogs;
//extern int dogs;
int main(int argc, char* argv[]) {
  std::cout << cats << std::endl;
  std::cout << dogs << std::endl;
  return 0;
}
```

总结一下就是：

1. 函数和变量的声明不会分配内存, 但是定义会分配相应的内存空间
2. 函数和变量的声明可以有很多次, 但是定义最多只能有一次
3. **函数的声明和定义方式默认都是 extern 的, 即函数默认是全局(外部)的**
4. 除了全局变量外，其他变量(const、static、clas)的声明和定义方式默认都是局部(内部)的, 在当前编译单元或者文件内可用

### extern “C” - C/C++ 混合编程

在一个项目中，能否既包含 C++ 程序又包含 C 程序呢？换句话说，C++ 和 C 可以进行混合编程吗？要知道，在 C++ 出现之前，很多实用的功能都是用 C 语言开发的，很多底层的库也是用 C 语言编写的。这意味着，如果能在 C++ 代码中兼容 C 语言代码，无疑能极大地提高 C++ 程序员的开发效率。

而恰恰答案也正是我们想要的，C++ 和 C 可以进行混合编程。但需要注意的是，由于 C++ 和 C 在程序的编译、链接等方面都存在一定的差异，而这些差异往往会导致程序运行失败。

举个例子，如下就是一个用 C++ 和 C 混合编程实现的实例项目：

```cpp
//myfun.h
void display();
//myfun.c
#include <stdio.h>
#include "myfun.h"
void display(){
   printf("C++：http://c.biancheng/net/cplus/");
}
//main.cpp
#include <iostream>
#include "myfun.h"
using namespace std;
int main(){
   display();
   return 0;
}
```

在此项目中，主程序是用 C++ 编写的，而 display() 函数的定义是用 C 语言编写的。从表面上看，这个项目很完整，我们可以尝试运行它：

```csharp
In function `main': undefined reference to `display()'
```

如上是调用 GCC 编译器运行此项目时给出的错误信息，指的是编译器无法找到 main.cpp 文件中 display() 函数的实现代码。**导致此错误的原因，就是因为 C++ 和 C 编译程序的方式存在差异**。**我们知道，之所以 C++ 支持函数的重载，是因为 C++ 会在程序的编译阶段对函数的函数名进行“再次重命名”**，例如：

- void Swap(int a, int b) 会被重命名为`_Swap_int_int`；
- void Swap(float x, float y) 会被重命名为`_Swap_float_float`。

**显然通过重命名，可以有效避免编译器在程序链接阶段无法找到对应的函数。**

**但是，C 语言是不支持函数重载的，它不会在编译阶段对函数的名称做较大的改动。**仍以 void Swap(int a, int b) 和 void Swap(float x, float y) 为例，若以 C 语言的标准对它们进行编译，两个函数的函数名将都是_Swap。这也就意味着，使用 C 和 C++ 进行混合编程时，考虑到对函数名的处理方式不同，势必会造成编译器在程序链接阶段无法找到函数具体的实现，导致链接失败。

幸运的是，C++ 给出了相应的解决方案，即借助 extern "C"，就可以轻松解决 C++ 和 C 在处理代码方式上的差异性。extern 是 C 和 C++ 的一个关键字，但对于 extern "C"，读者大可以将其看做一个整体，和 extern 毫无关系。**extern "C"既可以修饰一句 C++ 代码，也可以修饰一段 C++ 代码，它的功能是让编译器以处理 C 语言代码的方式来处理修饰的 C++ 代码**。