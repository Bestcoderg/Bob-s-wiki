# C++ 模板编译的过程

模板只应用于 “编译” 阶段，就像宏只应用于 “预处理” 阶段一样。千万别和 “链接” 阶段和 “运行” 阶段搞混。我们将模板在编译过程中的处理分为四个阶段。

### 名字查找

名字查找，是当程序中出现一个名字时，将其与引入它的声明联系起来的过程。对于模板来说，一个名字可以有多个声明。对于函数而言，这有一个天坑 “参数依赖查找”。参数依赖查找可能会引入新的声明，从而可能改变重载集 ，简直是万恶之源。这里就先不说参数依赖查找了。

### 模板实参推导

找到名字的多个声明之后，我们要对函数模板进行模板实参推导。推导的意思是编译器必须根据函数模板的 “函数参数” 推导出“每个模板参数的类型”。

```cpp
template <typename T, typename D>
	void f(T, D) {}
```

假如我们有这样的函数模板，那么对于`f(5, "abc");`进行推导，得到的结果是`[T = int, D = const char*]` 当然，显式指定的参数，例如`f<int, double>(5, 2.3);` 直接得到`[T = int, D = double]`

**如果推导失败的话（这里指的不是SFINA）**（例如，两个函数参数共同推导一个模板参数，但推导出来的结果不一样）**那么放弃这个声明，去看别的声明。如果推导成立，那么这个函数成为了 “候选函数”。**

### **重载决议**

如果我们最后有若干个候选函数，那么需要决定到底该选谁。**对于函数模板的调用`f<>(2, 3.5);`的意思是只对重载集合中的函数模板进行重载决议，而`f(2, 3.5);`则允许非模板函数参与重载决议。**

怎么决定呢？我们先把推导出来的类型带入函数模板中。**如果替换失败了**（例如我们推导出来`[T = int]`，但是函数模板的签名中有`typename T::type`），**那么这个候选函数就从重载集合中扔掉。这就是传说中的 “SFINAE”。**

对于推导出来的类型，我们有一套偏序规则，来决定剩下的候选函数哪个更好。注意，**只有泛化的函数模板参与重载决议。只有在重载决议选择最佳匹配的泛化函数模板后，才去看这个函数模板的特化版本。**

### **实例化**

经过了以上旅程，我们终于可以实例化了。实例化有两种，一种是显式实例化，一种是隐式实例化。显式实例化的应用场景比较少。事实上，对于函数模板的调用语句，如果当前翻译单元没有模板的定义，只有模板的声明，那么模板是不会隐式实例化的，编译器仅仅把函数的调用当作调用而已。如果当前的函数模板已经被实例化了，编译器也不会进行隐式实例化，编译器仅仅把函数的调用当作调用而已。

实例化的内容比较简单，**就是编译器把参数都带入进函数模板里，然后生成一个函数实例。在这之后，在各种意义上，一个函数模板的调用就和正常的非模板函数没有区别了。**注意，模板只是实例化的模式，函数模板根本不是函数，类模板也根本不是类。**一定要记住，模板只是一个模式，而不是具体的东西**。

所以，这就是很坑的地方。如果我的翻译单元 A 里面隐式的实例化了函数模板，翻译单元 B 依赖于这个隐式实例化。如果 A 不小心改了这个隐式实例化，那 B 就不能正常工作了。所以我们需要显式实例化。

要注意的是，**特化的函数模板甚至都不算一个 “名字”。偏特化也是一样。可以认为，在名字查找的时候，都没有看到特化的函数模板，特化的函数模板更不可能出现在重载决议的集里面了。**也就是说，对于这样的代码。

```cpp
template <typename T> void f(T) {} // 1
template <> void f(int*) {} // 2
template <typename T> void f(T*) {} // 3

int* p = nullptr;
f(p);
```

调用的是 3。因为 2 是 1 的特化，**在重载决议的时候，只考虑 1 和 3 的偏序关系，显然 3 优于 1**。

当然，**重载决议决定了当前的泛化模板，编译器去看这个泛化模板的偏特化版本的时候，也需要进行推导和替换。此时，SFINAE 也会发挥作用，这也是类模板可以进行 SFINAE 的原因。**

在实例化的过程中，对于函数体里的依赖于模板参数的名字进行名字查找。实际上，模板有二段名称查找规则。**第一遍（模板定义时）查找函数体里不依赖于模板参数的名字以及进行必要的语法分析（**static_assert如果传入常量将在第一遍检查的时候就assert调，这也就是为什么[SFINAE 初探](SFINAE%20%E5%88%9D%E6%8E%A2%200b3ac8b652a9497a876fd4347ff6a1a5.md) 中需要再实现一个 `__declval_protector` 模板，不然在有模板偏特化的场景下，不管偏特化的模板怎么写都会编译报错**）。第二遍（模板实例化时）查找函数体里依赖于模板参数的名字以及生成实例**。**就是因为有二段名称查找，所以我们在模板语境下才需要写`template`和`typename`让编译器在函数模板的第一遍名字查找的时候，对语法有一个正确的分析**。