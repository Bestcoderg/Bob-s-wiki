# 乐观锁&悲观锁

## 什么是**悲观锁**

顾名思义，悲观锁是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，**在线程释放锁之前任何线程都不能对其数据进行操作，直到前面一个线程把锁释放后下一个线程数据加锁才可对数据进行加锁**，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的。**Java synchronized 就属于悲观锁的一种实现**，每次线程要修改数据时都先获得锁，当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。

特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高。

## 什么是**乐观锁**

乐观锁是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到**数据提交的时候才通过一种机制来验证数据是否存在冲突**(一般实现方式是通过加版本号然后进行版本号的对比方式实现)。**Java JUC中的atomic包就是乐观锁的一种实现，AtomicInteger 通过CAS（Compare And Set）操作实现线程安全的自增。关于CAS可以看：**

[CAS / 无锁队列](CAS%20%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%20b27493e0a10a40338f1904781e050b7f.md)

特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式大大的提高了数据操作的性能。