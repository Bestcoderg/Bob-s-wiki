# 程序在内存中的存储位置

## 让我们先来看看ELF文件

![%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%20ca4bdf90aeab41ae963add936a0a0241/Untitled.png](%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%20ca4bdf90aeab41ae963add936a0a0241/Untitled.png)

ELF 分为三种类型：.o 可重定位文件 (relocalble file)，可执行文件以及共享库 (shared library)，三种格式基本上从结构上是一样的，只是具体到每一个结构不同。下面我们就从整体上看看这 3 种格式从文件内容上存储的方式，spec 上有张图是比较经典的：如上图：

其实从文件存储的格式来说，上面的两种 view 实际上是一样的，Segment 实际上就是由 section 组成的，将相应的一些 section 映射到一起就叫 segment 了, 就是说 segment 是由 0 个或多个 section 组成的，实际上本质都是 section。在这里我们首先来仔细了解一下 section 和 segment 的概念：section 就是相同或者相似信息的集合，比如我们比较熟悉的. text .data .bss section。.text 是可执行指令的集合，.data 是初始化后数据的集合，.bss 是未初始化数据的集合。

实际上我们也可以将一个程序的所有内容都放在一起，就像 dos 一样，但是将可执行程序分成多个 section 是很有好处的，比如说我们可以将. text section 放在 memory 的只读空间内，将可变的. data section 放在 memory 的可写空间内。

从可执行文件的角度来讲，如果一个数据未被初始化那就不需要为其分配空间，所以. data 和. bss 一个重要的区别就是. bss 并不占用可执行文件的大小，它只是记载需要多少空间来存储这些未初始化数据，而不分配实际的空间。

**Q:*（如果说bss段不分配空间，那么静态变量不初始化就不会被分配空，等到调用的时候再分配空间？那么此时分配给这个静态变量的空间在哪里呢？如果是分配在static data区那也不合理呀，因为static data是静态分配的内存）***

## 让我们详解内存区域的分配

- 汇编语言的角度，一个程序分为：数据段 -- DS；堆栈段 -- SS；代码段 -- CS；扩展段 -- ES；
- 高级语言的角度，根据 APUE一个程序分为如下段：text；data (initialized)；bss；stack；heap

其实我们很少去思考一个问题，那就是程序在加载入内存之前是怎样的？

一般情况下，一个可执行二进制程序 (更确切的说，在 Linux 操作系统下为一个进程单元，在 UC/OSII 中被称为任务)在存储 (没有调入到内存运行) 时拥有 3 个部分，分**别是代码段 (text)、数据段(data) 和 BSS 段。这 3 个部分一起组成了该可执行程序的文件**。

- **可执行二进制程序 = 代码段 (text)＋数据段 (data)+BSS 段**

而当程序被加载到内存单元时，则需要另外两个域：**堆域和栈域**。下图所示为可执行**代码存储态和运行态的结构对照图**。一个正在运行的 C 程序占用的内存区域分为代码段、初始化数据段、未初始化数据段 (BSS)、堆、栈 5 个部分。

- **正在运行的 C 程序 = 代码段 + 初始化数据段 (data)+ 未初始化数据段 (BSS)+ 堆 + 栈**

在将应用程序加载到内存空间执行时，操作系统负责**代码段、数据段和 BSS 段**的加载，并将在内存中为这些段分配空间。栈亦由操作系统分配和管理，而不需要程序员显示地管理；堆段由程序员自己管理，即显示地申请和释放空间。

![%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%20ca4bdf90aeab41ae963add936a0a0241/Snipaste_2021-03-22_10-59-58.png](%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%20ca4bdf90aeab41ae963add936a0a0241/Snipaste_2021-03-22_10-59-58.png)

### 静态分配&动态分配

动态分配与静态分配，二者最大的区别在于: 1. 动态分配的内存直到 Run-Time 的时候，执行动态分配，而静态分配的内存在 compile-time 的时候，就已经决定好了分配多少 **Text+Data+BSS+Stack**。2. 动态分配的内存通过 malloc() 动态分配的内存，需要程序员手工调用 free() 释放内存，否则容易导致内存泄露，而静态分配的内存则在进程执行结束后系统释放 (Text, Data), 但 Stack 段中的数据很短暂，函数退出立即被销毁。

### 五个程序段

![Untitled](%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%20ca4bdf90aeab41ae963add936a0a0241/Untitled%201.png)

![Untitled](%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%20ca4bdf90aeab41ae963add936a0a0241/Untitled%202.png)

![%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%20ca4bdf90aeab41ae963add936a0a0241/Untitled%203.png](%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%20ca4bdf90aeab41ae963add936a0a0241/Untitled%203.png)

- 代码段 --text（code segment/text segment）
    
    text 段是程序代码段，在 AT91 库中是表示程序段的大小，它是由编译器在编译连接时自动计算的，当你在链接定位文件中将该符号放置在代码段后，那么该符号表示的值就是代码段大小，编译连接时，该符号所代表的值会自动代入到源程序中。**text 段在内存中被映射为只读，但. data 和. bss 是可写的。**
    
- 数据段 -- data
    
    data 包含静态初始化的数据，所以有初值的全局变量和 static 变量在 data 区。段的起始位置也是由连接定位文件所确定，大小在编译连接时自动分配，它和你的程序大小没有关系，但和程序使用到的全局变量，常量数量相关。数据段属于静态内存分配。
    
- bss 段 （**Block Started by Symbol**）
    
    bss 是英文 Block Started by Symbol 的简称，通常是指用来**存放程序中未初始化的全局变量**的一块内存区域，在程序载入时由内核清 0。**BSS 段属于静态内存分配。它的初始值也是由用户自己定义的连接定位文件所确定**，**用户应该将它定义在可读写的 RAM 区内**（源程序中使用 malloc 分配的内存就是这一块，主要由程序中同时分配内存最大值所确定，不过如果超出了范围，也就是分配失败，可以等空间释放之后再分配）
    
    **注意静态变量初始化为零和全局静态变量初始化为零的情况，都是存储在 bss 段**
    
    **对于 GNU 的编译器来说 虽说显式初始化成零和不初始化都会去. bss 段，但是在文件的大小上还是稍微有一些区别的，会把显示初始化的这个量占用一个 16 字节的描述。**
    
- stack 段
    
    栈 (stack) 保存函数的参数、返回值以及局部变量（但不包括 static 声明的变量， static 意味着 在数据段(data)中 存放变量）。“栈”是一种 “后进先出”的数据结构。对于那些暂时存贮的信息，和不需要长时间保存的信息来说，LIFO 这种数据结构非常理想。在调用函数或过程后，系统通常会清除栈上保存的局部变量、函数调用信息及其它的信息。栈另外一个重要的特征是，它的地址空间 “向下减少”，即当栈上保存的数据越多，栈的地址就越低。栈（stack）的顶部在可读写的 RAM 区的最后。
    
- heap 段
    
    堆 (heap) 保存函数内部动态分配内存，是另外一种用来保存程序信息的数据结构，更准确的说是保存程序的动态变量。堆是“先进先出”数据结构。它只允许在堆的一端插入数据，在另一端移走数据。堆的地址空间“向上增加”，即当堆上保存的数据越多，堆的地址就越高。
    

可以看到堆和栈是不断拓展的，但不同的是栈是有最大的空间限制的，而堆没有。堆(Heap)往高地址方向生长，栈(Stack)往低地址方向生长。

### **到底怎么减小我们的 BIN（可执行文件）:**

首先，尽量少用静态变量和全局变量。从效率和大小的角度来看，全局变量都不是最优选择（全局变量需要从非寄存器中加载）。

其次，如果必须要用全局变量，那也可以，尽量不要在定义时初始化，特别是不初始化成零的, 可以在函数中进行初始化。

然后我们看一下以下两端程序：

```cpp
/* 全局变量 a 未进行了初始化, 在函数中负责，但是 bin 大小却明显降低了 */
int a[1000];
int b[100];
int main()
{
    a[i] = i；
  }
  return 0;
}
```

```cpp
/* 全局变量 a 进行了初始化 */
int a[1000] = {1,2,3,4,5,6};
int b[100];
int main()
{
  return 0;
}
```

发现程序 2 编译之后所得的. exe 文件比程序 1 的要大得多。当下甚为不解，于是手工编译了一下，并使用了 / FAs 编译选项来查看了一下其各自的. asm，发现在程序 1.asm 中 ar 的定义如下：

```cpp
程序 1.asm 中 ar 的定义如下：
_BSS SEGMENT
     ?ar@@3PAHA DD 0493e0H DUP (?)    ; ar
_BSS ENDS 
而在程序 2.asm 中，ar 被定义为：
_DATA SEGMENT
     ?ar@@3PAHA DD 01H     ; ar
                DD 02H
                DD 03H
                ORG $+1199988
_DATA ENDS
```

区别很明显，**一个位于. bss 段，而另一个位于. data 段**，两者的区别在于：全局的未初始化变量存在于. bss 段中，具体体现为一个占位符；全局的已初始化变量存于. data 段中；而函数内的自动变量都在栈上分配空间。

.bss 是不占用. exe 文件空间的，其内容由操作系统初始化（清零）；而. data 却需要占用，其内容由程序初始化，因此造成了上述情况。