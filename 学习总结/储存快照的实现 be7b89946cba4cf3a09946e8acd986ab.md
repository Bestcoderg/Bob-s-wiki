# 储存快照的实现

快照的定义：关于指定数据集合的一个完全可用拷贝，该拷贝包括相应数据在某个时间点（拷贝开始的时间点）的映像。快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。

需要注意的是：**快照是完全可用的拷贝，但不是一份完整的拷贝。**（不然还能“快”吗？o.o）

目前，快照的实现方式均由各个厂商自行决定，但主要技术分为2类，一种是写时拷贝COW（Copy On Write），另一种，是写重定向ROW（Redirect On Write）。

## 写时拷贝COW

COW(Copy-On-Write)，写时拷贝，也称为写前拷贝。

创建快照以后，如果源卷的数据发生了变化，那么快照系统会首先将原始数据拷贝到快照卷上对应的数据块中，然后再对源卷进行改写。

### 写操作

![%E5%82%A8%E5%AD%98%E5%BF%AB%E7%85%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%20be7b89946cba4cf3a09946e8acd986ab/1.gif](%E5%82%A8%E5%AD%98%E5%BF%AB%E7%85%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%20be7b89946cba4cf3a09946e8acd986ab/1.gif)

如上图简要示例，快照创建以后，若上层业务对源卷写数据X，**X在缓存中排队，快照系统将X即将写入的位置（逻辑地址）上的数据Y，拷贝到快照卷中对应的位置（逻辑地址）上，同时，生成一张映射表，表中一列记录源卷上数据变化的逻辑地址，另一列记录快照卷上数据变化的逻辑地址。**我们可以看到，上层业务每下发一个数据块，存储上，发生了**两次写操作**：一次是源卷将数据写入快照卷（即图中Y），一次是上层业务将数据写入源卷（即图中X）。

### 读快照操作

![%E5%82%A8%E5%AD%98%E5%BF%AB%E7%85%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%20be7b89946cba4cf3a09946e8acd986ab/2.gif](%E5%82%A8%E5%AD%98%E5%BF%AB%E7%85%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%20be7b89946cba4cf3a09946e8acd986ab/2.gif)

如上图，快照卷若映射给上层业务进行数据分析等用途时，**针对快照**进行读操作时，首先由快照系统判断，上层业务需要读取的数据是否在快照卷中**，若在，直接从快照卷读取，若不在，则查询映射表，去对应源卷的逻辑地中读取**（这个查表并去源卷读的操作，也叫**读重定向**）。这一点，恰好就解释了为什么快照是一份完全可用的副本，**它没有对源卷进行100%的拷贝**，但对上层业务来说，却可以将快照看做是和源卷“一模一样”的副本。

**针对源卷进行读操作时，与快照卷没有数据交互。**

我们可以看到，快照对源卷的数据具有很好的保护措施，快照可以单独作为一份可以读取的副本，但并没有像简单的镜像那样，一开始就占用了和源卷一样的空间，而是根据创建快照后上层业务产生的数据，来实时占用必需的存储空间。

### 快照回滚

![%E5%82%A8%E5%AD%98%E5%BF%AB%E7%85%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%20be7b89946cba4cf3a09946e8acd986ab/3.gif](%E5%82%A8%E5%AD%98%E5%BF%AB%E7%85%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%20be7b89946cba4cf3a09946e8acd986ab/3.gif)

回滚操作的前提条件是，**锁定源卷（暂停对待回滚的逻辑地址上的IO操作）**，然后通过查映射表，将快照卷上的对应数据回拷到源卷中。

### 删除快照

采用COW技术的快照，其源卷即保存着完整的实时数据，因此，删除快照时，直接销毁了**快照卷和映射表**，与源卷不存在数据交互。

## 写重定向ROW

ROW(Redirect-on-write )，也称为写时重定向。

创建快照以后，快照系统把对数据卷的写请求重定向给了快照预留的存储空间，**直接将新的数据写入快照卷。**上层业务读源卷时，创建快照前的数据从源卷读，创建快照后产生的数据，从快照卷读。这种快照方式更像是git的快照存储方式。

### 写操作

![%E5%82%A8%E5%AD%98%E5%BF%AB%E7%85%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%20be7b89946cba4cf3a09946e8acd986ab/4.gif](%E5%82%A8%E5%AD%98%E5%BF%AB%E7%85%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%20be7b89946cba4cf3a09946e8acd986ab/4.gif)

如上图简要示例，快照创建以后，若上层业务对源卷写数据X，X在缓存中排队，**快照系统判断X即将写入源卷的逻辑地址，然后将数据X写入快照卷中预留的对应逻辑地址中**，同时，将源卷和快照卷的逻辑地址写入映射表，即写重定向。我们可以看到，上层针对源卷写入一个数据块X，存储上只发生一次写操作，只是写之前进行了重定向。

### 读操作

若快照创建以后，上层业务对源卷进行读，则有两种情况：1）若读取的数据，在创建快照前产生，数据是保存在源卷上的，那么，上层就从源卷进行读取；2）若需要读取的数据是创建快照以后才产生的，那么上层就查询映射表，从快照卷进行读取（即读重定向）。

若**快照创建以后**，上层业务**对快照卷进行读**，同样也有两种情况：1）若读取的数据，在创建快照前产生，数据是保存在源卷上的，那么上层就查询映射表，从源卷进行读取；2）若需要读取的数据是创建快照以后才产生的，那么上层就直接从快照卷进行读取。

我们可以看到，ROW快照也是根据创建快照后上层业务产生的数据，来实时占用必需的存储空间。

### 快照回滚

采用ROW技术的快照，**其源卷始终保存着快照创建前的完整数据**，快照创建后，上层业务产生的数据都写入了快照中，因此，**快照的回滚只是取消了对源卷的读重定向操作**。通俗地说，就是源卷上没有进行任何数据操作，上层业务对源卷的读，仅限于读源卷（即不会去读取快照卷的数据）。

### 快照删除

![%E5%82%A8%E5%AD%98%E5%BF%AB%E7%85%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%20be7b89946cba4cf3a09946e8acd986ab/5.gif](%E5%82%A8%E5%AD%98%E5%BF%AB%E7%85%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%20be7b89946cba4cf3a09946e8acd986ab/5.gif)

采用ROW技术的快照，其源卷始终保存着快照创建前的完整数据，快照创建后，上层业务产生的数据都写入了快照中。因此，若要删除快照，必然要先将快照卷中的数据，回拷到源卷中，拷贝完成才能删除，如上图。此时我们可以设想，如果，针对一份源数据，在18:00创建了快照，上层业务持续产生大量新的数据，19:00又创建了快照，20:00又创建了快照……那么，在有多份快照的情况下，如果需要删除快照，就会出现，多个快照向源卷回拷数据的情况，可能导致回拷量非常大，耗时很长。

## 两种技术比较

![%E5%82%A8%E5%AD%98%E5%BF%AB%E7%85%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%20be7b89946cba4cf3a09946e8acd986ab/Untitled.png](%E5%82%A8%E5%AD%98%E5%BF%AB%E7%85%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%20be7b89946cba4cf3a09946e8acd986ab/Untitled.png)

COW的写时拷贝，导致每次写入都有拷贝操作，大量写入时，源卷的写性能会有所下降，而读源卷是不会受到任何影响的，删除快照时，只是解除了快照和源卷的关系，同时删除了快照卷的数据而已。ROW在每次写入仅做了重定向操作，这个操作耗时是几乎可以忽略不计的，源卷的写性能几乎不会受到影响，但读源卷时，则需要判断数据是创建快照前还是创建快照后，导致大量读时，性能受到一定影响，比较致命的是，若源卷有多个快照，在删除快照时，所有快照的数据均需要回拷到源卷才可以保证源卷数据的完整性。