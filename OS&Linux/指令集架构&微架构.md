# 指令集架构&微架构

今天很尴尬的将AMD和ARM搞混了，从而让我有了进一步了解指令集架构&微架构以及当前几个大厂之间设计的区别。说到架构，应该很多人最先想到的是x86&ARM这两种，但很多时候又会提到一些一代cpu架构这种比较让人迷惑的信息。同时，我们要明确一个优秀的指令集架构&微架构对于性能的影响，由于 CPU性能 = 逻辑CPU核数 * 主频 * IPC。（IPC就是每个时钟周期内可以执行的指令数(IPC: Instruction Per Clock)，指令集架构&微架构的更新换代直接影响和提高的是IPC值）

## 指令集架构&微架构

CPU执行计算任务时都需要遵从一定的规范，程序在被执行前都需要先翻译为CPU可以理解的语言。这种**规范或语言就是指令集**（ISA，Instruction Set Architecture）。程序被按照某种指令集的规范翻译为CPU可识别的底层代码的过程叫做编译（compile）。**x86、ARM v8、MIPS都是指令集的代号。**指令集可以被扩展，**如x86增加64位支持就有了x86-64**。厂商开发兼容某种指令集的CPU需要指令集专利持有者授权，典型例子如Intel授权AMD，使后者可以开发兼容x86指令集的CPU。

CPU的基本组成单元即为核心（core）。多个核心可以同时执行多件计算任务，前提是这些任务没有先后顺序。**核心的实现方式被称为微架构（microarchitecture）**。微架构的设计影响核心可以达到的最高频率、核心在一定频率下能执行的运算量、一定工艺水平下核心的能耗水平等等。此外，不同微架构执行各类程序的偏向也不同，例如90年代末期Intel的P6微架构就在浮点类程序上表现优异，但在整数类应用中不如同频下的对手。

常见的代号如Haswell、Cortex-A15等都是微架构的称号。**注意微架构与指令集是两个概念：指令集是CPU选择的语言，而微架构是具体的实现**。i7-4770的核心是Haswell微架构，这种微架构兼容x86指令集。对于兼容ARM指令集的芯片来说这两个概念尤其容易混淆：ARM公司将自己研发的指令集叫做ARM指令集，同时**它还研发具体的微架构如Cortex系列并对外授权**。但是，一款CPU使用了ARM指令集不等于它就使用了ARM研发的微架构。Intel、高通、苹果、Nvidia等厂商都自行开发了兼容ARM指令集的微架构，同时还有许多厂商使用ARM开发的微架构来制造CPU。通常，业界认为只有具备独立的微架构研发能力的企业才算具备了CPU研发能力，而是否使用自行研发的指令集无关紧要。微架构的研发也是IT产业技术含量最高的领域之一。

总的来说，指令集架构更加趋近于一种设计规范，CPU的设计需要支持这种规范。而微架构更加趋近于对某种指令集的具体实现形式。

## 指令集架构：CISC&RISC

目前两种主要的计算机处理器体系结构：

CISC（Complex Instruction Set Computer,复杂指令集计算机）

RISC（Reduced Instruction Set Computer,精简指令集计算机）

**CISC（复杂指令集）**即 冯·诺依曼结构（普林斯顿结构），**指令与数据存储在同一存储器中；**采用CISC结构的处理器，指令线与数据线分时复用；程序指令存储地址与数据存储地址指向同一个存储器的不同物理位置，则程序指令和数据的宽度相同；取指令与取数据不能同时进行，速度受限；目前采用CISC指令集设计的主要有：x86_64、x86。

通俗理解：我们要命令一个人吃饭，那么我们应该怎么命令呢？我们可以直接对他下达“吃饭”的命令，也可以命令他“先拿勺子，然后舀起一勺饭，然后张嘴，然后送到嘴里，最后咽下去”。从这里可以看到，对于命令别人做事这样一件事情，不同的人有不同的理解，有人认为，如果我首先给接受命令的人以足够的训练，让他掌握各种复杂技能（即在硬件中实现对应的复杂功能），那么以后就可以用非常简单的命令让他去做很复杂的事情——比如只要说一句“吃饭”，他就会吃饭。

**RISC（精简指令集）**即 哈佛结构，**指令与数据存储于两个不同的存储空间；程序存储器与数据存储器相互独立，独立编址，独立访问；**分离的程序总线与数据总线在一个机器周期中，可同时获得指令字和操作数，提高执行效率；取指令和取数据同时进行，且一般指令线宽与数据线，可包含更多的处理信息；目前采用RISC指令集设计的主要有：IBM PowerPC、ARM。

通俗理解：有人认为这样吃饭整套流程会让事情变的太复杂，毕竟接受命令的人要做的事情很复杂，如果你这时候想让他吃菜怎么办？难道继续训练他吃菜的方法？我们为什么不可以把事情分为许多非常基本的步骤，这样只需要接受命令的人懂得很少的基本技能，就可以完成同样的工作，无非是下达命令的人稍微累一点——比如现在我要他吃菜，只需要把刚刚吃饭命令里的“舀起一勺饭”改成“舀起一勺菜”。

### CISC架构

目前我们所遇到采用CISC的CPU体系架构按照名称主要分为两大类：IA和x86，在这两类下又分别划分有32位和64位。按照这样的分类，就出现了四种体系架构名称：IA-32，IA-64，X86-32，X86-64。

**x86：x86是Intel公司首先研发的一种CPU体系架构**，这种体系架构也常被称为80×86。该系列最早的处理器即为16位的Intel 8086。由于Intel早年对于这个系列的处理器都是以80开头并以86结尾，比如Intel 8086、80186、80286及80386等，因此用x86或者80×86表示该体系架构，其中“x”即为英文字母x。值得注意的是，x86代表一类处理器的体系架构，并不特指Intel公司的处理器，比如AMD公司也生产遵循x86架构的处理器。另外，x86体系架构包含16位、32位和64位。

**x86-32：**表示32位的x86体系架构，该系列也被称为IA-32或i386，甚至直**接使用x86来代表这种体系**架构。该架构的第一款CPU为Intel 80386，它完全取代了16位x86架构的CPU。32位系统有两种模式，**实模式：**相当于高性能的16位[8086](https://baike.baidu.com/item/8086)微处理器，但进行了功能扩充，能够使用8086所没有的寻址方式和32位通用寄存器以及大部分指令。不具有保护机制，不能使用部分特权指令。实模式下只有20条地址线有效，存储空间为1MB。**保护模式：**充分发挥[IA-32](https://baike.baidu.com/item/IA-32)微处理器的存储管理功能和硬件支持的保护机制，为多任务操作系统设计提供支持。该模式下每个任务的存储空间为4GB。

**x86-64：表示64位的x86体系架构。该架构由AMD公司首推，因此AMD将其称为AMD64。**Intel随后也推出了64位的x86架构，将其称为Intel64。由于这两个64位的架构几乎相同，因此许多其他厂商使用不偏袒任何厂商的称呼x86-64来表示对这两个架构的兼容。该架构有时也被称为x86_64或x64，某些厂商也用AMD64或amd64同时表示Intel64和AMD64。两者的核心指令集一致，其他的一些部分会有不同的实现方式。

**IA-32：**表示英特尔32位元架构，英文全称为Intel Architecture 32-bit.它与x86-32表示同一种体系架构，只不过Intel现如今将x86-32称为IA-32。

**IA-64：表示Intel与惠普合作开发的一种崭新的64位体系架构，它与x86架构不兼容，也由于这个原因，市场对IA-64的反响不好，导致后来Intel转向x86_64**。因此，IA-64与上面提到的x86-64或x64代表的含义不同。

## 微架构研发

在PC时代，几大主要的CPU研发厂商都只是自己研制微架构自己用。到了智能设备时代，ARM公司的**微架构授权模式**兴起。ARM自己开发微架构后将它们上架出售，其他厂商可以拿这些核心组装为芯片来使用或销售。由于这种模式对第三方的技术能力要求很低，加上ARM的微架构在低功耗领域表现优异，这种模式获得了广泛成功。如果你发现某款芯片标明使用了**Cortex**系列核心，则一定是这种模式的产物。如前所述，仅仅从ARM购买微架构来组装芯片的厂商是不能被称作CPU研发企业的，这些芯片也不能被称为“xx厂商研发的CPU”。典型如华为的海思920、三星Exynos 5430，只能说是“使用ARM Cortex-A15核心的芯片”。但是如果一款兼容ARM指令集的芯片使用了厂商自主研发的微架构情况就不同了。高通骁龙800、苹果A7就是这样的例子--它们分别使用了高通、苹果自主研发的CPU。

随着智能设备市场不断扩大，ARM阵营也不断壮大。占领智能设备领域后，ARM阵营开始进入PC、服务器与高性能计算领域。先是ARM发布了ARM v8 64位指令集规范，接着是各大厂商纷纷开始研发基于ARM v8的高性能微架构。有人会问，ARM指令集不是为低功耗设备研发的吗？怎么现在又开始做高性能CPU了呢？多年以前这样的怀疑是很有道理的，因为彼时不同指令集对微架构的影响还比较大，ARM适合低功耗，x86适合PC，Power适合小型机……这类区分是存在的。**但是随着技术进步，指令集对微架构的影响已经小到可以忽略，任何指令集都可以做出适合不同领域的优秀微架构来。**因此用户看到x86指令集的手机cpu或是ARM指令集的服务器CPU都无需惊讶，这是技术发展的自然结果。

那么，现在各家CPU研发厂商选择指令集的标准又是什么呢？一般来说大家倾向于选择软件生态较好的指令集--前面说过，软件必须编译后才能在某种指令集平台上运行，而编译是很复杂的事情，绝大多数闭源软件仅仅会对少数一两个平台编译。因而支持某种指令集的软件应用越多，这种指令集也就越有市场优势--新开发的微架构只需要兼容某种指令集，那么就可以很容易运行大量为其开发的软件。早年因为微软的强势与Wintel联盟的推动，x86指令集成了最受欢迎的角色，帮助Intel用彼时性能相对落后的微架构在PC平台挤跑了一众对手。后PC时代由于苹果谷歌的两大操作系统平台的推动，ARM指令集又取得了绝对的市场优势。但对于新的CPU研发单位来说，他们想获得热门指令集的兼容授权是很困难的事情。以前x86与ARM的指令集授权是拿钱买不到的，想要得到都需要进行高水平专利交换。拿到x86授权的几家厂商要么是拿的早（AMD、Cyrix、IDT），要么是有高水平技术与Intel交易（Transmeta，以功耗控制技术同Intel交易）。后来Nvidia想要研发自己的CPU，找Intel软磨硬泡后者就是不给，搞得Nvidia相当无奈。国内的研发单位当年开始研究时自知不可能拿到x86授权，于是各自去找关系好些的其他授权方解决问题了。ARM这边也一直对指令集授权卡的很死，之前只有高通、博通和Intel得到，也是通过技术交换的形式。08年苹果乔帮主被Intel甩脸色后决定自己搞CPU，最后也拿到了ARM的许可，想来彼时老乔也是威逼利诱，硬是让ARM屈服了（毕竟指令集多授权一家就多个对手啊）。后来ARM对指令集授权也放松了，去年三星与华为也分别得到了授权。

![%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84&%E5%BE%AE%E6%9E%B6%E6%9E%84%203235c38c9c194fa392c539748aa2e00b/Untitled.png](%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84&%E5%BE%AE%E6%9E%B6%E6%9E%84%203235c38c9c194fa392c539748aa2e00b/Untitled.png)

## 苹果与安卓都是ARM架构，为什么软件不通用

对于这个问题其实回答是很简单的，首先应用软件对接的层级应该是操作系统，如果希望软件通用那个需要操作系统一样或是给出相同的接口。但是IOS和Android显然不能做到这一点。IOS是使用Ojective-C开发，而Android是使用安卓开发，就算下一层，安卓也是基于java开发的。java与Objective-C之间的距离依旧还是不可逾越的。

虽然两者都是用的是ARM指令集架构，但是两者的微架构差距极大，两种不同的玩法（泛制化vs定制化），自然出来的东西差别巨大。这两者的芯片使用起来的性能便是不一样的。在芯片之上还有操作系统，两者之间也是泛制化vs定制化之间的差别。