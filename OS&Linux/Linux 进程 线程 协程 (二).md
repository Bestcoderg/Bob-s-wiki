# Linux 进程|线程|协程 (二)

本文是继 [Linux 进程|线程|协程 (一)](OS&Linux 进程 线程 协程 (一).md) 后对进程、线程协程关系的又一次的深入理解。时隔了半年，在看这个问题，不经感到之前的我理解的粗浅(或是说我变强了？哈哈哈哈 ㄟ( ▔, ▔ )ㄏ )如果说前一篇文章是将轮廓描绘出来的话，那么这篇文章将深入计算机操作系统程序控制设计，将细节处讲透。由于涉及的知识点比较多，可能会导致这篇文章引用大量的子文章。

## 进程

什么是进程呢？我们在计算机打开一个软件如打开了steam便是打开了一个进程，换一个科学的说法，一段程序在计算机中的执行过程即为进程。

由于CPU的速度极快，而进程总会有一些“低效”的需求，如等待 IO的输入，显然如果让某个进程一直占用着CPU资源而处理一些“低效”的问题是一种浪费。所以在有了进程后，又有了多进程间切换的需要。

![Untitled](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%BA%8C)%2034cfd0229d1944da910cb6edcc1429d5/Untitled.png)

这种多程序 交替执行 的方式，就是 CPU 管理多进程初步思想。可能会有人问了， 交替执行会不会很慢，这个不用担心，因为 CPU 的执行速度与切换速度非常的快，可能就是几十或几百毫秒，超出了人类的感知，一秒钟内可能就交替运行了多个进程，所以给我们产生 并行 的错觉，其实这叫并发。单核 多进程交替执行 就是并发，多进程在多核运行就是并行。

### PCB 进程控制块

显然，在进程切换过程中，我们需要保存进程的上下文。那么就需要某个结构能够保存进程的上下文，同时操作系统管理进程也需要某个结构实体。这就是 PCB 进程控制块， PCB 包含了进程运行所必要的一些信息，**具体可以看** **[Linux 进程控制块PCB](Linux%20%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB%202d908aa06c3b4b59bfe309147b0004b4.md) （包含了进程的管理方式）**

- 进程描述信息
    - 进程唯一的标记符，类似唯一 id
    - 用户标识符，进程归属的用户，用户标识符主要为共享和保护服务
- 进程控制和管理信息
    - 进程当前状态，比如运行、就绪、阻塞等，作为处理机分配调度的依据
    - 进程优先级，描述进程抢占处理机的优先级，优先级高的进程可以优先获得处理机
- 资源分配清单
    - 用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的输入 / 输出设备信息
- CPU 相关信息
    - 指 CPU 中各寄存器值，当进程被切换时，CPU 状态信息都必须保存在相应的 PCB 中，以便进程重新执行时，能再从断点继续执行。

### 进程状态

进程状态怎么说呢，这部分内容只能说是弃之可惜，食之无味。所以就只简单地贴个图

- 进程三态

![Untitled](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%BA%8C)%2034cfd0229d1944da910cb6edcc1429d5/Untitled%201.png)

- 进程五态

![Untitled](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%BA%8C)%2034cfd0229d1944da910cb6edcc1429d5/Untitled%202.png)

- 进程七态
  
    其实进程还有一种状态叫挂起态，挂起态代表该进程不会占用内存空间，**它会被换出到硬盘空间保存**，当需要使用它的时候，**会被换入，加载到内存**，挂起态可以分为下面两种
    
    - 阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现
    - 就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行

![Untitled](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%BA%8C)%2034cfd0229d1944da910cb6edcc1429d5/Untitled%203.png)

### 进程上下文切换

我们上面提到了PCB与程序状态，这两者都与进程的上下文切换密切相关。我们将 CPU 从一个进程切换到另一个进程的过程称为进程的上下文切换。[Linux 进程栈|线程栈|内核栈|中断栈](Linux%20%E8%BF%9B%E7%A8%8B%E6%A0%88%20%E7%BA%BF%E7%A8%8B%E6%A0%88%20%E5%86%85%E6%A0%B8%E6%A0%88%20%E4%B8%AD%E6%96%AD%E6%A0%88%20af1be01df9c64ca284343cd634cd795d.md) 
[用户态与内核态](%E7%94%A8%E6%88%B7%E6%80%81%E4%B8%8E%E5%86%85%E6%A0%B8%E6%80%81%20adab1cb05ecc4cb6beebc9f0542e7ea2.md) 

在说进程上下文切换之前，先来聊聊 **CPU 上下文切换**

**CPU 上下文 是指 CPU 寄存器 和 程序计数器**

- CPU 寄存器 是 CPU 内置的容量小，速度极快的缓存
- 程序计数器是用来存储是 CPU 正在执行的指令位置或即将执行的下一条指令位置

CPU 上下文切换 就很好理解了，就是把前一个任务的 CPU 上下文 保存起来，然后在加载当前任务的 CPU 上下文，最后再跳转到 程序计数器 所指的新位置，运行任务。

上面说到所谓的「任务」，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成：**进程上下文切换、线程上下文切换和中断上下文切换。**

**进程的上下文是怎么切换的：**

首先进程是由内核管理与调度的，所以 进程上下文切换 发生在内核态，进程上下文切换的内容**包含栈、寄存器、虚拟内存、文件句柄**等，但相对比较稳定安全。相较线程的切换，**进程还多了许多信息的保存，如多级页表。**

在做上下文切换的时候，会把前一个 进程 的上下文保存到它的 PCB 中，然后加载当前 进程 的 PCB 上下文到 CPU 中，使得 进程 继续执行

![Untitled](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%BA%8C)%2034cfd0229d1944da910cb6edcc1429d5/Untitled%204.png)

发生进程上下文切换的场景

- 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，切换到其它正在等待 CPU 的进程运行
- 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。
- 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。
- 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行
- 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。

### 传统线程缺点

现实中有很多需要并发处理的任务，如数据库的服务器端、网络服务器、大容量计算等。一个任务是一个进程，传统的 UNIX 进程是单线程（执行流）的，单线程意味着程序必须是顺序执行，单个任务不能并发；既在一个时刻只能运行在一个处理器上，因此不能充分利用多处理器框架的计算机。如果采用多进程的方法，即把一个任务用多个进程解决，则有如下问题：

a. fork 一个子进程的消耗是很大的，fork 是一个昂贵的系统调用，即使使用现代的写时复制 (copy-on-write) 技术。

b. 各个进程拥有自己独立的地址空间，进程间的协作需要复杂的 IPC 技术，如消息传递和共享内存等。

## 线程

在早期操作系统都是以 进程 为独立运行的基本单位，直到后面，计算机科学家又提出了更小的能独立运行的基本单位，它就是线程。因为 **进程的切换 = 资源切换 + 指令执行序列切换**。将资源和指令序列分开看，如果只是从一个执行指令序列切换到另一个执行指令序列，那么这就是线程的切换。

在现代操作系统，进程是最小的资源分配单位，线程是最小的运行单位，一个进程下面能有一个或多个线程，每个线程都有独立一套的寄存器和栈，这样可以确保线程的控制流是相对独立的。

![Untitled](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%BA%8C)%2034cfd0229d1944da910cb6edcc1429d5/Untitled%205.png)

线程带来的好处有以下几点

- 一个进程中可以同时存在多个线程
- 让进程具备多任务并行处理能力
- 同进程下的各个线程之间可以共享进程资源 （同进程内的多线程通信十分简单高效）
- 更轻量与高效

线程带来的坏处有以下几点

- 因为进程资源共享，所以会产生资源竞争，需要通过锁机制来协同
- **当进程中的一个线程奔溃时，会导致其所属进程的所有线程奔溃**（一般游戏的用户设计不会采用多线程方式）

### **线程与进程的对比**

一个进程的组成实体可以分为两大部分：线程集合和资源集合。进程中的线程是动态的对象；代表了进程指令的执行。资源，包括地址空间、打开的文件、用户信息等等，由进程内的线程共享。线程有自己的私有数据：程序计数器，栈空间以及寄存器。

- 进程是最小的资源（包括内存、打开的文件等）分配单位，线程是最小的运行单位
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈
- 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系（和进程大同小异）
- 线程的创建、终止时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，所以线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们（线程管理的资源较少）
- 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），**这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的**
- **由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了**

### 线程的上下文切换

![Untitled](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%BA%8C)%2034cfd0229d1944da910cb6edcc1429d5/Untitled%206.png)

当进程只有一个线程时，可以认为进程等于线程，线程上下文的切换分两种情况

1. 不同进程的线程，切换的过程就跟进程上下文切换一样
2. 两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据

所以线程的上下文切换相比进程，开销要小很多

### 线程的调度

我们不讨论进程，进程的意义是 “隔离的执行环境”，而不是 “单独的执行序列”。

我们首先需要理解 IA-32 CPU 的指令控制方式，这样才能理解如何在多个指令序列 (也就是逻辑控制流) 之间进行切换。首先需要改变指令寄存器的值，CPU 通过 CS:EIP 寄存器的值确定下一条指令的位置，但是 CPU 并不允许直接使用 MOV 指令来更改 EIP 的值，必须通过 JMP 系列指令、CALL/RET 指令、或 INT 中断指令来实现代码的跳转；在指令序列间切换的时候，除了更改 EIP 之外，我们还要保证代码可能会使用到的各个寄存器的值，尤其是栈指针 SS:ESP，以及 EFLAGS 标志位等，都能够恢复到目标指令序列上次执行到这个位置时候的状态。

线程是操作系统对外提供的服务，应用程序可以通过系统调用让操作系统启动线程，并负责随后的线程调度和切换。我们先考虑单颗单核 CPU，操作系统内核与应用程序其实是也是在共享同一个 CPU，当 EIP 在应用程序代码段的时候，内核并没有控制权，内核并不是一个进程或线程，内核只是以实模式运行的，代码段权限为 RING 0 的内存中的程序，只有当产生中断或是应用程序呼叫系统调用的时候，控制权才转移到内核，在内核里，所有代码都在同一个地址空间，为了给不同的线程提供服务，**内核会为每一个线程建立一个内核堆栈，这是线程切换的关键**。通常，内核会在时钟中断里或系统调用返回前，对整个系统的线程进行调度，计算当前线程的剩余时间片，如果需要切换，就在“可运行” 的线程队列里计算优先级，选出目标线程后，则保存当前线程的运行环境，并恢复目标线程的运行环境，其中最重要的，就是切换堆栈指针 ESP，然后再把 EIP 指向目标线程上次被移出 CPU 时的指令。Linux 内核在实现线程切换时，耍了个花枪，它并不是直接 JMP，而是先把 ESP 切换为目标线程的**内核栈**，把目标线程的代码地址压栈，然后 JMP 到[__switch_to()](http://lxr.linux.no/linux+v3.8.2/arch/x86/kernel/process_32.c#L248)，相当于伪造了一个 CALL __switch_to() 指令，然后，在__switch_to() 的最后使用 RET 指令返回，这样就把栈里的目标线程的代码地址放入了 EIP，接下来 CPU 就开始执行目标线程的代码了，其实也就是上次停在[switch_to](http://lxr.linux.no/linux+v3.8.2/arch/x86/include/asm/switch_to.h#L31)这个宏展开的地方。

## 线程的模型

在说线程模式之前，先介绍 3 个概念

- 内核线程：在内核空间就实现的线程，由内核管理
- 用户线程：在用户空间实现的线程，不归内核管理，是由用户态通过线程库完成线程的管理（用户态是指线程或进程在用户空间运行）
- 轻量级进程：在内核中来支持用户线程（用户线程与内核线程的中间层，内核线程的高度抽象）

### 内核线程

用户态线程和内核态线程；主要的区分就是 “谁来管理” 线程，用户态是用户管理，内核态是内核管理。因为内核线程是由内核空间管理，所以它的 结构线程控制块（Thread Control Block, TCB） 在内核空间，操作系统对 TCB 是可见的

![Untitled](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%BA%8C)%2034cfd0229d1944da910cb6edcc1429d5/Untitled%207.png)

内核线程有什么优点

- 内核线程的由内核空间管理，线程的创建、销毁、调度等，都不用你操心，全自动化，属于智能型
- 内核线程能利用 cpu 多核的特性，实现并行执行（因为由内核管理，非常智能）
- 内核线程阻塞，不会影响其他内核线程（因为由内核管理，非常智能）

内核线程有什么缺点

- 因为是内核管理，所以内核线程的大部分操作都涉及到内核态，即需要从用户态切换到内核态，开销较大
- 因为内核资源有限，所以无法大量创建内核线程

### 用户线程

因为 用户线程 在用户空间，是由 用户态 通过线程库来管理，所以它的 结构线程控制块（Thread Control Block, TCB） 也是在线程库里面，对于操作系统而言是看不到 TCB 的，它只能看到整个进程的 PCB（内核无法管理用户线程，也感知不到用户线程）

![Untitled](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%BA%8C)%2034cfd0229d1944da910cb6edcc1429d5/Untitled%208.png)

用户线程有什么优点

- 因为用户线程创建、销毁、调度等都不走内核态，直接在用户态进行操作，所以速度特别快
- 不依赖内核，可用于不支持线程技术的操作系统
- 可以大量创建用户线程，不消耗内核资源

用户线程有什么缺点

- 用户线程创建、销毁、调度等需要自己实现相应线程库
- **用户线程阻塞会导致整个进程内的其他用户线程阻塞（整个进程阻塞），因为内核感知不到用户线程，所以无法去调度其他用户线程**
- **无法利用 cpu 多核特性，还是因为内核感知不到用户线程**

### 轻量级进程 LWP (Light-weight process)

既然称作轻量级进程，可见其本质仍然是进程，与普通进程相比，LWP 与其它进程共享所有（或大部分）逻辑地址空间和系统资源，一个进程可以创建多个 LWP，这样它们共享大部分资源；LWP 有它自己的进程标识符，并和其他进程有着父子关系；这是和类 Unix 操作系统的系统调用 vfork() 生成的进程一样的。LWP 由内核管理并像普通进程一样被调度。Linux 内核是支持 LWP 的典型例子。Linux 内核在 2.0.x 版本就已经实现了轻量进程，应用程序可以通过一个统一的 clone() 系统调用接口，用不同的参数指定创建轻量进程还是普通进程，通过参数决定子进程和父进程共享的资源种类和数量，这样就有了轻重之分。在内核中， clone() 调用经过参数传递和解释后会调用 do_fork()，这个核内函数同时也是 fork()、vfork() 系统调用的最终实现。[Linux 进程栈|线程栈|内核栈|中断栈](Linux%20%E8%BF%9B%E7%A8%8B%E6%A0%88%20%E7%BA%BF%E7%A8%8B%E6%A0%88%20%E5%86%85%E6%A0%B8%E6%A0%88%20%E4%B8%AD%E6%96%AD%E6%A0%88%20af1be01df9c64ca284343cd634cd795d.md) 

在大多数系统中，**LWP 与 普通进程 的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息**。一般来说，一个进程代表程序的一个实例，而 LWP 代表程序的执行线程，因为一个 执行线程 不像进程那样需要那么多状态信息，所以 LWP 也不带有这样的信息。个人认为，所谓LWP与实际的进程，是对于task_struct结构的复用，关键在于这个task_struct是拥有独立的资源还是与其他进程共享资源。

### 一对一模型（内核级线程模型）

LWP 就是一对一模型，即 进程 只需要创建使用 LWP ，因为一个 LWP 由一个 内核线 程支持，所以最终是内核管理线程，可以调度到其他处理器上（再简单点解释，直接使用内核线程）

![Untitled](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%BA%8C)%2034cfd0229d1944da910cb6edcc1429d5/Untitled%209.png)

一对一模型（1:1）的优缺点就不多说了，上面介绍内核线程的时候已经说过了，但是值得一提的是，jvm 采用该模型实现线程，所以在 Java 中启动一个线程需要谨慎

### 一对多模型（用户级线程模型）

一对多模型，即多个用户级线程 对用到同一个 LWP 上实现，因为是用户态通过用户空间的线程库对线程管理，所以速度特别快，不会涉及到用户态与内核态的转换

![Untitled](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%BA%8C)%2034cfd0229d1944da910cb6edcc1429d5/Untitled%2010.png)

一对多模型（n:1）的优点缺点体现在用户级线程上面，用户线程的优缺点前面说过，这里不做概述，值得一提的是 Python 中的协程就是通过该模型实现。

### 多对多模型（两级线程模型）

多对多模型是集各家所长诞生的产物，它充分吸收前两种线程模型的优点且尽量避免它们的缺点。

首先它区别于多对一模型，多对多模型进程内的 多用户线程 可以绑定不同的内核线程 ，这点与 一对一模型 类似，其次又区别于一对一模型，进程内的 多用户线程 与 内核线程 不是一对一绑定，而是动态绑定，当某个 内核线程 因绑定的 用户线程 执行阻塞操作，让出 CPU 时，绑定该 内核线程 的其他 用户线程 可以解绑，重新绑定到其他 内核线程 继续运行。

所以多对多模型（m:n），即不是多对一模型完全靠自己实现的线程库调度，也不是一对一模型完全靠操作系统调度，而是一个中间态系统（负责自身调度与操作系统调度的协同工作），最后提一句 Go 语言使用的是多对多模型，这也是其高并发的原因，它的线程模型与 Java 中的 ForkJoinPool 非常类似。

![Untitled](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%BA%8C)%2034cfd0229d1944da910cb6edcc1429d5/Untitled%2011.png)

多对多模型优点

- 兼具多对一模型的轻量
- 由于对应了多个内核线程，则一个用户线程阻塞时，其他用户线程仍然可以执行
- 由于对应了多个内核线程，则可以实现较完整的调度、优先级等；

多对多模型缺点

- 实现复杂（因为这种模型的高度复杂性，操作系统内核开发者一般不会使用，所以更多时候是作为第三方库的形式出现）

## 调度算法

- **先来先服务算法（First Come First Severd, FCFS）**
  
    先来先服务算法简称 FCFS，顾名思义，谁先来，谁先被 CPU 执行，后到的就乖乖排队等待，十分简单的算法，CPU 每次调度 就绪队列 的第一个进程，直到进程退出或阻塞，才会把该进程入队到队尾，然后接着继续调度第一个进程，依此类推。
    

![Untitled](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%BA%8C)%2034cfd0229d1944da910cb6edcc1429d5/Untitled%2012.png)

FCFS 算法看似很公平，但是当一个长作业先运行了，后面的短作业等待的时间就会很长，所以不利于短作业，会降低系统吞吐量。FCFS 对长作业有利，适用于 C P U 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。

- **最短作业优先算法（Shortest Job First, SJF）**
  
    同样也是顾名思义，它会优先选择运行时间最短的进程，有助于提高系统吞吐量。但是对长作业不利，所以很容易造成一种极端现象。比如，一个 长作业 在就绪队列等待运行，而这个就绪队列有非常多的短作业，最终使得 长作业 不断的往后推，周转时间变长，致使长作业长期不会被运行（适用于 I/O 繁忙型作业的系统）。
    

![Untitled](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%BA%8C)%2034cfd0229d1944da910cb6edcc1429d5/Untitled%2013.png)

- **高响应比优先算法 （Highest Response Ratio Next, HRRN）**

因为前面的「先进先出算法」和「最短作业优先算法」都没有很好的权衡短作业和长作业，所以高响应比优先算法主要是权衡了短作业和长作业。每次进行进程调度时，先计算「响应比优先权」，然后把「响应比优先权」最高的进程投入运行。

![Untitled](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%BA%8C)%2034cfd0229d1944da910cb6edcc1429d5/Untitled%2014.png)

- **时间片轮转（Round Robin, RR）算法**
  
    时间片轮转是最古老、最简单、最公平且使用最广的算法，给每个进程分配相同时间片（Quantum），允许进程在该时间段中运行
    
    ![Untitled](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%BA%8C)%2034cfd0229d1944da910cb6edcc1429d5/Untitled%2015.png)
    
    - 如果时间片用完，进程还在运行，将会把此进程放入就绪队列，并继续调度另外一个进程，依此类推
    - 如果该进程在时间片结束前阻塞或结束，则调度另外一个进程
    
    进程时间片用完，需要被重新分配时间片.需要注意的是，如果时间片设置的太短，会导致 CPU 上下文切换态频繁，太长又可能引起对短作业进程的响应时间变长，所以时间片设为 20ms~50ms 通常是一个比较合理的折中值
    
- **最高优先级（Highest Priority First，HPF）算法**
  
    前面的「时间片轮转算法」让所有的进程同等重要，不偏袒谁，大家的运行时间都一样。但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，希望调度程序能从就绪队列中选择最高优先级的进程运行，这就是最高优先级（Highest Priority First，HPF）算法
    
    进程的优先级可以分为：
    
    - 静态优先级：创建进程时候，已经确定优先级，整个运行时间优先级都不会变化
    - 动态优先级：根据进程的动态变化调整优先级，比如进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则提高优先级。
    
    有两种处理优先级高的方法：
    
    - 非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。
    - 抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。
    
    但是依然有缺点，可能会导致低优先级的进程永远不会运行。
    
- **多级反馈队列（Multilevel Feedback Queue）算法**
  
    多级反馈队列（Multilevel Feedback Queue）算法 是基于「时间片轮转算法」和「最高优先级算法」演进而来，如同它的名字一样，根据优先级分组成多个队列，在算法中涉及两个概念：
    
    - 「多级」表示有多个队列，每个队列优先级从高到低，优先级越高的队列拥有的时间片越短
    - 「反馈」 表示有新的进程进入优先级高的队列时，停止当前运行进程，去运行优先级高的队列

![Untitled](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%BA%8C)%2034cfd0229d1944da910cb6edcc1429d5/Untitled%2016.png)

- 多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短
- 新进的 进程 会被放入 第一级队列 尾部，按先来先服务的原则排队等待被调度，如果第一级队列时间片用完，还有进程没有执行，把第一级队列剩余的进程 放入 第二级队列的尾部，依此类推
- 当优先级高队列为空，正在运行低优先级队列的进程时，有新进程 进入 高优先级队列，这时立即停止当前运行进程，把当前进程放入 原队列 尾部，转而去 运行 高优先级队列的进程。

可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，很好的兼顾了长短作业，同时有较好的响应时间。

## Linux线程发展

直以来, linux 内核并没有线程的概念. 每一个执行实体都是一个 task_struct 结构, 通常称之为进程. Linux 内核在 2.0.x 版本就已经实现了轻量进程，**应用程序可以通过一个统一的 clone() 系统调用接口，用不同的参数指定创建轻量进程还是普通进程**。在内核中， clone() 调用经过参数传递和解释后会调用 do_fork()，这个核内函数同时也是 fork()、vfork() 系统调用的最终实现。后来为了引入多线程，Linux2.0~2.4 实现的是俗称 LinuxThreads 的多线程方式，到了 2.6，基本上都是 NPTL 的方式了。下面我们分别介绍。

### **模型一 ：LinuxThreads**

linux 2.6 以前, pthread 线程库对应的实现是一个名叫 LinuxThreads 的 lib. 这种实现本质上是一种 LWP 的实现方式，即通过轻量级进程来模拟线程，内核并不知道有线程这个概念，在内核看来，都是进程。

**Linux 采用的 “一对一” 的线程模型，即一个 LWP 对应一个线程。这个模型最大的好处是线程调度由内核完成了，而其他线程操作（同步、取消）等都是核外的线程库函数完成的。**

**linux 上的线程就是基于轻量级进程, 由用户态的 pthread 库实现的**. 使用 pthread 以后, 在用户看来, 每一个 task_struct 就对应一个线程, 而一组线程以及它们所共同引用的一组资源就是一个进程. 但是, 一组线程并不仅仅是引用同一组资源就够了, 它们还必须被视为一个整体.

**对此, POSIX 标准提出了如下要求:**

1. 查看进程列表的时候, 相关的一组 task_struct 应当被展现为列表中的一个节点;
2. 发送给这个 "进程" 的信号 (对应 kill 系统调用), 将被对应的这一组 task_struct 所共享, 并且被其中的任意一个 "线程" 处理;
3. 发送给某个 "线程" 的信号 (对应 pthread_kill), 将只被对应的一个 task_struct 接收, 并且由它自己来处理;
4. 当 "进程" 被停止或继续时 (对应 SIGSTOP/SIGCONT 信号), 对应的这一组 task_struct 状态将改变;
5. 当 "进程" 收到一个致命信号 (比如由于段错误收到 SIGSEGV 信号), 对应的这一组 task_struct 将全部退出;
6. 等等 (以上可能不够全);

在 LinuxThreads 中，专门为每一个进程构造了一个管理线程，负责处理线程相关的管理工作。当进程第一次调用 pthread_create() 创建一个线程的时候就会创建并启动管理线程。然后管理线程再来创建用户请求的线程。也就是说，用户在调用 pthread_create 后，**先是创建了管理线程，再由管理线程创建了用户的线程。**

LinuxThreads 利用前面提到的轻量级进程来实现线程, 但是对于 POSIX 提出的那些要求, **LinuxThreads 除了第 5 点以外, 都没有实现 (实际上是无能为力)**:

- 如果运行了 A 程序, A 程序创建了 10 个线程, 那么在 shell 下执行 ps 命令时将看到 11 个 A 进程, 而不是 1 个 (注意, 也不是 10 个, 下面会解释);
- 不管是 kill 还是 pthread_kill, 信号只能被一个对应的线程所接收;
- SIGSTOP/SIGCONT 信号只对一个线程起作用;

还好 **LinuxThreads** 实现了第 5 点, 我认为这一点是最重要的. 如果某个线程 "挂" 了, 整个进程还在若无其事地运行着, 可能会出现很多的不一致状态. 进程将不是一个整体, 而线程也不能称为线程. 或许这也是为什么 **LinuxThreads** 虽然与 POSIX 的要求差距甚远, 却能够存在, 并且还被使用了好几年的原因吧~

接下来要说说, 为什么 A 程序创建了 10 个线程, 但是 ps 时却会出现 11 个 A 进程了. 因为 **LinuxThreads** 自动创建了一个管理线程. 上面提到的 "第 5 点" 就是靠管理线程来实现的.当程序开始运行时, 并没有管理线程存在 (因为尽管程序已经链接了 pthread 库, 但是未必会使用多线程).

程序第一次调用 pthread_create 时, **LinuxThreads**  发现管理线程不存在, 于是创建这个管理线程. 这个管理线程是进程中的第一个线程 (主线程) 的儿子.

然后在 pthread_create 中, 会通过 pipe 向管理线程发送一个命令, 告诉它创建线程. 即是说, 除主线程外, 所有的线程都是由管理线程来创建的, 管理线程是它们的父亲.于是, **当任何一个子线程退出时, 管理线程将收到 SIGUSER1 信号 (这是在通过 clone 创建子线程时指定的). 管理线程在对应的 sig_handler 中会判断子线程是否正常退出, 如果不是, 则杀死所有线程, 然后自杀.**

那么, 主线程怎么办呢? 主线程是管理线程的父亲, 其退出时并不会给管理线程发信号. 于是, 在管理线程的主循环中通过 getppid 检查父进程的 ID 号, 如果 ID 号是 1, 说明父亲已经退出, 并把自己托管给了 init 进程 (1 号进程). 这时候, 管理线程也会杀掉所有子线程, 然后自杀.

**可见, 线程的创建与销毁都是通过管理线程来完成的, 于是管理线程就成了 linuxthreads 的一个性能瓶颈.**创建与销毁需要一次进程间通信, 一次上下文切换之后才能被管理线程执行, 并且多个请求会被管理线程串行地执行.

这种通过 LWP 的方式来模拟线程的实现看起来还是比较巧妙的，但也存在一些比较严重的问题：

1）线程 ID 和进程 ID 的问题

按照 POSIX 的定义，同一进程的所有的线程应该共享同一个进程和父进程 ID，而 Linux 的这种 LWP 方式显然不能满足这一点。

2）信号处理问题

异步信号是以进程为单位分发的，而 Linux 的线程本质上每个都是一个进程，且没有进程组的概念，所以某些缺省信号难以做到对所有线程有效，例如 SIGSTOP 和 SIGCONT，就无法将整个进程挂起，而只能将某个线程挂起。

3）线程总数问题

LinuxThreads 将每个进程的线程最大数目定义为 1024，但实际上这个数值还受到整个系统的总进程数限制，这又是由于线程其实是核心进程。

4) 管理线程问题

管理线程容易成为瓶颈，这是这种结构的通病；同时，管理线程又负责用户线程的清理工作，因此，尽管管理线程已经屏蔽了大部分的信号，但一旦管理线程死亡，用户线程就不得不手工清理了，而且用户线程并不知道管理线程的状态，之后的线程创建等请求将无人处理。

5) 同步问题

LinuxThreads 中的线程同步很大程度上是建立在信号基础上的，这种通过内核复杂的信号处理机制的同步方式，效率一直是个问题。

6）其他 POSIX 兼容性问题

Linux 中很多系统调用，按照语义都是与进程相关的，比如 nice、setuid、setrlimit 等，在目前的 LinuxThreads 中，这些调用都仅仅影响调用者线程。

7）实时性问题

线程的引入有一定的实时性考虑，但 LinuxThreads 暂时不支持，比如调度选项，目前还没有实现。不仅 LinuxThreads 如此，标准的 Linux 在实时性上考虑都很少

### **模型二：NPTL**

到了 linux 2.6, glibc 中有了一种新的 pthread 线程库 --NPTL(Native POSIX Threading Library).

本质上来说，NPTL 还是一个 LWP 的实现机制，但相对原有 LinuxThreads 来说，做了很多的改进。下面我们看一下 NPTL 如何解决原有 LinuxThreads 实现机制的缺陷

**NPTL 实现了前面提到的 POSIX 的全部 5 点要求. 但是, 实际上, 与其说是 NPTL 实现了, 不如说是 linux 内核实现了.**

在 linux 2.6 中, 内核有了线程组的概念, task_struct 结构中增加了一个 tgid(thread group id) 字段.

如果这个 task 是一个 "主线程", 则它的 tgid 等于 pid, 否则 tgid 等于进程的 pid(即主线程的 pid).

在 clone 系统调用中, 传递 CLONE_THREAD 参数就可以把新进程的 tgid 设置为父进程的 tgid(否则新进程的 tgid 会设为其自身的 pid).

类似的 XXid 在 task_struct 中还有两 个：task->signal->pgid 保存进程组的打头进程的 pid、task->signal->session 保存会话 打头进程的 pid。通过这两个 id 来关联进程组和会话。

有了 tgid, 内核或相关的 shell 程序就知道某个 tast_struct 是代表一个进程还是代表一个线程, 也就知道在什么时候该展现它们, 什么时候不该展现 (比如在 ps 的时候, 线程就不要展现了).

而 getpid(获取进程 ID) 系统调用返回的也是 tast_struct 中的 tgid, 而 tast_struct 中的 pid 则由 gettid 系统调用来返回.

在执行 ps 命令的时候不展现子线程，也是有一些问题的。比如程序 a.out 运行时，创建 了一个线程。假设主线程的 pid 是 10001、子线程是 10002（它们的 tgid 都是 10001）。这时如果你 kill 10002，是可以把 10001 和 10002 这两个线程一起杀死的，尽管执行 ps 命令的时候根本看不到 10002 这个进程。如果你不知道 linux 线程背 后的故事，肯定会觉得遇到灵异事件了。

为了应付 "发送给进程的信号" 和 "发送给线程的信号", task_struct 里面维护了两套 signal_pending, 一套是线程组共享的, 一套是线程独有的.

通过 kill 发送的信号被放在线程组共享的 signal_pending 中, 可以由任意一个线程来处理; 通过 pthread_kill 发送的信号 (pthread_kill 是 pthread 库的接口, 对应的系统调用中 tkill) 被放在线程独有的 signal_pending 中, 只能由本线程来处理.

当线程停止 / 继续, 或者是收到一个致命信号时, 内核会将处理动作施加到整个线程组中.