# 虚拟内存(内核空间&用户空间)

**内核也是程序，也应该具有自己的虚存空间**，但是作为一种为用户程序服务的程序，内核空间有它自己的特点。（虚拟内存的管理可以看：[Linux 进程控制块PCB](Linux%20%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB%202d908aa06c3b4b59bfe309147b0004b4.md) ）

**目录：**

---

![%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled.png](%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled.png)

![%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%201.png](%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%201.png)

![Untitled](%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%202.png)

![Untitled](%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%203.png)

## 内核空间与用户空间

在一个 32 位系统中，一个程序的虚拟空间最大可以是 4GB。由于内核与程序都需要跑在系统中，那么我们想到最直接的处理方法就是把内核也看作是一个程序，使它和其他程序一样也具有 4GB 空间。但是这种做法会导致**系统不断的切换用户程序的页表和内核页表**，以致影响计算机的效率。

所以我们采用了另一种解决方案，就是把 4GB 空间分成两个部分：一部分为用户空间，另一部分为内核空间，这样就可以保证内核空间固定不变，而当程序切换时，**改变的仅是程序的页表(无需切换内核页表)**。这种做法的唯一缺点便是内核空间和用户空间均变小了。通常 32 位 Linux 内核以 **PAGE_OFFSET** 为界，将虚拟地址空间划分 0~3G 为用户空间，3~4G 为内核空间 (注意，内核可以使用的线性地址只有 1G)。注意这里是 32 位内核地址空间划分，64 位内核地址空间划分是不同的。

当系统中运行多个程序时，多个用户空间与内核空间的关系可以表示如下图：

![%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%204.png](%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%204.png)

如图中所示，程序 1、2……n 共享内核空间。当然，这里的共享指得是分时共享，因为在任何时刻，对于单核处理器系统来说，只能有一个程序在运行。

## 内核空间的总体布局

实际上，随着硬件设备的更新和技术水平的提高，其内核空间布局的也在不断改变。目前，人们认为 Linux 内核(32_bit)空间有三个区域，即 DMA 区（ZONE_DMA）、普通区（ZONE_NORMAL）和高端内存区（ZONE_HIGHMEM）。、

### 实际物理内存较小时内核空间的直接映射

早期计算机实际配置的物理内存通常只有几 MB，所以为了提高内核通过虚拟地址访问物理地址内存的速度，**内核空间的虚拟地址与物理内存地址采用了一种从低地址向高地址依次一一对应的固定映射方式**，如下图所示：

![%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%205.png](%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%205.png)

可以看到，这种固定映射方式使得虚拟地址与物理地址的关系变得很简单，即内核虚拟地址与实际物理地址只在数值上相差一个固定的偏移量 **PAGE_OFFSET**，**所以当内核使用虚拟地址访问物理页框时，只需在虚拟地址上减去 PAGE_OFFSET 即可得到实际物理地址**，比使用页表的方式要快得多！

由于这种做法几乎就是直接使用物理地址，所以这种按固定映射方式的内核空间也就叫做 “物理内存空间”，简称物理内存。另外，**由于固定映射方式是一种线性映射，所以这个区域也叫做线性映射区**。

当然，这种情况下（计算机实际物理内存较小时），内核固定映射空间仅占整个 1GB 内核空间的一部分。例如：在配置 32MB 实际物理内存的 x86 计算机系统时，内核的固定映射区便是 **PAGE_OFFSET~（PAGE_OFFSET+0x02000000）这个 32MB 空间**。那么内核空间剩余的内核虚拟空间怎么办呢？

剩下的这部分内核虚拟空间是以**页表的非线性映射方式使用物理内存**。**具体来说，在整个 1GB 内核空间中去除固定映射区，然后在剩余部分中再去除其开头部分的一个 8MB 隔离区，余下的就是映射方式与用户空间相同的普通虚拟内存映射区**。在这个区，虚拟地址和物理地址不仅不存在固定映射关系，而且通过调用内核函数 vmalloc() 获得动态内存，故这个区就被称为 vmalloc 分配区，如下图所示：

![%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%206.png](%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%206.png)

对于配置 32MB 实际物理内存的 x86 计算机系统来说，vmalloc 分配区的起始位置为 **PAGE_OFFSET+0x02000000+0x00800000**

这里说明一下：**这里说的内核空间与物理页框的固定映射，实质上是内核页对物理页框的一种 “预定”，并不是说这些页就“霸占” 了这些物理页框。即只有当虚拟页真正需要访问物理页框时，虚拟页才与物理页框绑定**。**而平时，当某个物理页框不被与它对应的虚拟页所使用时，该页框完全可以被用户空间以及后面所介绍的内核 kmalloc 分配区**使用。

总之，在实际物理内存较小的系统中，实际内存的大小就是内核空间的物理内存区与 vmalloc 分配区的边界。

### 内核空间内存分区

- **ZONE_DMA** & **ZONE_NORMAL**

对于整个 1GB 的内核空间，人们还把该空间头部的 16MB 叫做 DMA 区，即 ZONE_DMA 区，**因为以往硬件将 DMA 空间固定在了物理内存的低 16MB 空间（注意这是物理内存空间的分布决定了内核空间的分布）；直接映射区的其余区则叫做普通区，即 ZONE_NORMAL。**

随着计算机技术的发展，计算机的实际物理内存越来越大，从而使得内核固定映射区（线性区）也越来越大。显然，如果不加以限制，当实际物理内存达到 1GB 以上时，vmalloc 分配区（非线性区）将不复存在，切有一部分内存内核无法访问到。这是不能被允许的。

下图就表示了这种内核空间所面临的局面：

![%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%207.png](%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%207.png)

显然，出现上述问题的原因就是没有预料到实际物理内存可以超过 1GB，因而没有为内核固定映射区的边界设定限制，而任由其随着实际物理内存的增大而增大。

解决上述问题的方法就是：**对内核空间固定映射区的上限加以限制，使之不能随着物理内存的增加而任意增加。**Linux 规定，内核映射区的上边界的值最大不能大于一个小于 1G 的常数 high_menory，当实际物理内存较大时，以 3**G+high_memory 为边界来确定物理内存区。（**例如：对于 x86 系统，high_memory 的值为 896M，于是 1GB 内核空间余下的 128MB 为非线性映射区。这样就确保在任何情况下，内核都有足够的非线性映射区以兼容早期代码并可以按普通虚存方式访问实际物理内存的 1GB 以上的空间。）

- **内核空间的高端内存 ZONE_HIGHMEM**

习惯上，Linux 把内核空间 3G+high_memory~4G-1 的这个部分叫做高端内存区（**ZONE_HIGHMEM**）当计算机是物理内存较大时，内核空间的示意图如下：

![%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%208.png](%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%208.png)

高端内存的最基本思想：**借一段地址空间，建立临时地址映射，用完后释放，达到这段地址空间可以循环使用，访问所有物理内存。**

总结一下：在 x86 结构的内核空间，三种类型的区域（从 3G 开始计算）如下：

- **ZONE_DMA：内核空间开始的 16MB**
- **ZONE_NORMAL：内核空间 16MB~896MB（固定映射）**
- **ZONE_HIGHMEM ：内核空间 896MB ~ 结束（1G）**

### 详解高端内存区

根据应用目标不同，**高端内存区分 vmalloc 区、可持久映射区和临时映射区。**内核空间中高端内存的布局如下图所示：

![%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%209.png](%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%209.png)

![Untitled](%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%2010.png)

- **vmalloc 映射区**

vmalloc 映射区是高端内存的主要部分，该区间的头部与内核线性映射空间之间有一个 8MB 的隔离区，尾部与后续的可持久映射区有一个 4KB 的隔离区。

**vmalloc 映射区的映射方式与用户空间完全相同，内核可以通过调用函数 vmalloc() 在这个区域获得内存。这个函数的功能相当于用户空间的 malloc()，所提供的内存空间在虚拟地址上连续（注意，不保证物理地址连续）。**

- **可持久内核映射区**

如果是通过 alloc_page() 获得了高端内存对应的 page，如何给它找个线性空间？

内核专门为此留出一块线性空间，从 PKMAP_BASE 开始，用于映射高端内存，就是可持久内核映射区。

**在可持久内核映射区，可通过调用函数 kmap() 在物理页框与内核虚拟页之间建立长期映射。这个空间通常为 4MB，最多能映射 1024 个页框，数量较为稀少，所以为了加强页框的周转，应及时调用函数 kunmap() 将不再使用的物理页框释放。**

- **临时映射区**

临时映射区也叫固定映射区和保留区。该区主要应用在多处理器系统中，因为在这个区域所获得的内存空间没有所保护，故所获得的内存必须及时使用；否则一旦有新的请求，该页框上的内容就会被覆盖，所以这个区域叫做临时映射区。

## 内核常用内存分配及地址映射函数

- vmalloc()

函数 vmalloc() 在 **vmalloc 分配区分配内存**，可获得虚拟地址连续，但并不保证其物理页框连续的较大内存。与物理空间的内存分配函数 malloc() 有所区别，vmalloc() 分配的物理页不会被交换出去。函数 vmalloc() 的原型如下：（其中，参数 size 为所请求内存的大小，返回值为所获得内存虚拟地址指针）

```cpp
void *vmalloc(unsigned long size)
{
       return __vmalloc(size, GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL);
}
void *__vmalloc(unsigned long size, gfp_t gfp_mask, pgprot_t prot)
{
	return kmalloc(size, (gfp_mask | __GFP_COMP) & ~__GFP_HIGHMEM);
}
//与 vmalloc() 配套的释放函数如下：
void vfree(const void *addr)
{
	kfree(addr);
}
```

- kmalloc()

kmalloc() 是内核另一个常用的内核分配函数，**它可以分配一段未清零的连续物理内存页，返回值为直接映射地址**。由 kmalloc() 可分配的内存最大不能超过 32 页。其优点是分配速度快，缺点是不能分配大于 128KB 的内存页（出于跨平台考虑）。

- alloc_pages()

与上述在虚拟空间分配内存的函数不同，alloc_pages() 是在物理内存空间分配物理页框的函数，**alloc_pages( )函数以gfp_mask分配方式分配2的order次方（1<<order）个连续的物理页。**

```cpp
static inline struct page * alloc_pages(gfp_t gfp_mask, unsigned int order)
{
		if (unlikely(order >= MAX_ORDER)) return NULL;
		return alloc_pages_current(gfp_mask, order);
}
```

函数返回值为页框块的第一个页框 struct_page 结构的地址。

- kmap()

kmap() 是一个映射函数，它可以将一个物理页框映射到内核空间的可持久映射区。这种映射类似于内核 ZONE_NORMAL 的固定映射，但虚拟地址与物理地址的偏移不一定是 PAGE_OFFSET。由于内核可持久映射区的容量有限（总共只有 4MB），因此当内存使用完毕后，应该立即释放。

### kmalloc、vmalloc、malloc 的区别

- kmalloc 和 vmalloc 是分配的是内核的内存，malloc 分配的是用户的内存；
- **kmalloc 保证分配的内存在物理上是连续的，vmalloc 保证的是在虚拟地址空间上的连续，malloc 不保证任何东西；**
- kmalloc 能分配的大小有限，vmalloc 和 malloc 能分配的大小相对较大；
- vmalloc 比 kmalloc 要慢。

也就是说：**kmalloc、vmalloc 这两个函数所分配的内存都处于内核空间，即从 3GB～4GB；但位置不同，kmalloc() 分配的内存处于 3GB～high_memory（ZONE_DMA、ZONE_NORMAL）之间，而 vmalloc() 分配的内存在 VMALLOC_START～4GB（ZONE_HIGHMEM）之间，也就是非连续内存区。一般情况下在驱动程序中都是调用 kmalloc() 来给数据结构分配内存，而 vmalloc() 用在为活动的交换区分配数据结构，为某些 I/O 驱动程序分配缓冲区，或为模块分配空间。**

![%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%2011.png](%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%2011.png)

## 内存分布小结

由于 CPU 的地址总线只有 32 位， 32 的地址总线无论是从逻辑上还是从物理上都只能描述 4G 的地址空间（2^32=4Gbit），在物理上理论上最多拥有 4G 内存（除了 IO 地址空间，实际内存容量小于 4G），逻辑空间也只能描述 4G 的线性地址空间。

为了合理的利用逻辑 4G 空间，Linux 采用了 3：1 的策略，即内核占用 1G 的线性地址空间，用户占用 3G 的线性地址空间。所以用户进程的地址范围从 0~3G，内核地址范围从 3G~4G，也就是说，内核空间只有 1G 的逻辑线性地址空间。

如果 Linux 物理内存小于 1G 的空间，通常内核把物理内存与其地址空间做了线性映射，也就是一一映射，这样可以提高访问速度。但是，当 Linux 物理内存超过 1G 时，线性访问机制就不够用了，因为只能有 1G 的内存可以被映射，剩余的物理内存无法被内核管理，所以，为了解决这一问题，**Linux 把内核地址分为线性区和非线性区两部分，线性区规定最大为 896M，剩下的 128M 为非线性区。从而，线性区映射的物理内存成为低端内存，剩下的物理内存被成为高端内存。与线性区不同，非线性区不会提前进行内存映射，而是在使用时动态映射。**

**低端内存又分成两部分：ZONE_DMA：内核空间开始的 16MB、ZONE_NORMAL：内核空间 16MB~896MB（固定映射）。剩下的就是高端内存：ZONE_HIGHMEM ：内核空间 896MB ~ 结束（1G）。**

**根据应用目标不同，高端内存区分 vmalloc 区、可持久映射区和临时映射区三部分。vmalloc 区使用 vmalloc() 函数进行分配；可持久映射区使用 allc_pages() 获得对应的 page，在利用 kmap() 函数直接映射；临时映射区一般用于特殊需求**

![%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled.png](%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled.png)

用户空间不是被进程共享的，而是被进程隔离的。每个进程最大可以有 3GB 用户空间。所以说一个进程对一个地址的访问，与另一个进程对同一个地址的访问不冲突，因为尽管是同一个地址但因为，进程的用户空间不共享 导致他们其实并没有指向同一个地址。而对于 cpu 来讲，在任意的时刻，整个系统都只有 4GB 的虚拟地址空间，这个**虚拟空间是面向进程的**，所以当进程切换的时候，虚拟地址空间也会切换。所以只有此进程运行的时候，其虚拟地址空间才被 CPU 所知。其他时刻，其虚拟空间不被 CPU 所知。

一个程序编译链接后形成的是虚拟地址空间，而程序最终要运行在物理内存中。所以，虚拟地址空间必须被映射到物理内存空间中，这个映射关系需要通过硬件体系结构所规定的数据结构来建立。**即段描述符表和页表，而 Linux 主要通过页表来进行映射。**

由以上得出一个结论。如果给出的页表不同，那么 CPU 将某一虚拟地址空间中的地址转化成的物理地址也不同，所以每个进程都建立了页表，将每个进程的虚拟地址空间根据自己的需要映射到物理地址空间上。既然在一个时刻 CPU 上只能有一个进程在运行，那么当进程发生切换时，将页表也更换为相应进程的页表，这就可以实现每个进程都有自己的虚拟地址空间而互不影响。

### Q&A

- **64 位内核中有高端内存吗？**
  
    目前现实中，64 位 Linux 内核不存在高端内存，因为 64 位内核可以支持超过 512GB 内存。若机器安装的物理内存超过内核地址空间范围，就会存在高端内存。
    
- **用户进程能访问多少物理内存？内核代码能访问多少物理内存？**
  
    32 位系统用户进程最大可以访问 3GB，内核代码可以访问所有物理内存。
    
    64 位系统用户进程最大可以访问超过 512GB，内核代码可以访问所有物理内存。
    
- **内核映像**
  
    在下面的描述中，我们把**内核的代码和数据就叫内核映像（kernel image）**。**当系统启动时，Linux 内核映像被安装在物理地址 0x00100000 开始的地方，即 1MB 开始的区间 (第 1M 留作它用)。**然而，在正常 运行时， 整个内核映像应该在虚拟内核空间中，因此，连接程序在连接内核映像时，在所有的符号地址上加一个偏移量 PAGE_OFFSET，这样，内核映像在内核空间 的起始地址就为 0xC0100000。
    
    例如，进程的页目录 PGD（属于内核数据结构）就处于内核空间中。在进程切换时，要将寄存器 CR3 设置成指 向新进程的页目录 PGD，而该目录的起始地址在内核空间中是虚地址，但 CR3 所需要的是物理地址，这时候就要用__pa() 进行地址转换。在 mm_context.h 中就有这么一行语句：
    
    `asm volatile(“movl %0,%%cr3”: :”r” (__pa(next-&gt;pgd));`
    
    这是一行嵌入式汇编代码，其含义是将下一个进程的页目录起始地址 next_pgd，通过__pa() 转换成物理地址，存放在某个寄存器中，然后用 mov 指令将其写入 CR3 寄存器中。经过这行语句的处理，CR3 就指向新进程 next 的页目录表 PGD 了
    

## 64位系统进程地址空间

在64位系统中，进程地址空间的大小就不固定了，以ARMv8-A为例，它的page大小可以是4KB, 16KB或者64KB（默认为4KB，选一种来用，不要混用），可采用3级页表或4级页表，因此可以有多种组合的形式。

以采用4KB的页，4级页表，虚拟地址为48位的系统为例（从ARMv8.2架构开始，支持虚拟地址和物理地址的大小最多为52位），**其虚拟地址空间的范围为$2^{48} = 256TB$，按照1:1的比例划分，内核空间和用户空间各占128TB。**

![%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%2012.png](%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%2012.png)

256TB已经很大很大了，但是面对64位系统所具备的16EB的地址范围，根本就用不完。为了以后扩展的需要（比如虚拟地址扩大到56位），用户虚拟空间和内核虚拟空间不再是挨着的，但同32位系统一样，还是一个占据底部，一个占据顶部，所以这时user space和kernel space之间偌大的区域就空出来了。

但这段空闲区域也不是一点用都没有，它可以辅助进行地址有效性的检测。如果某个虚拟地址落在这段空闲区域，那就是既不在user space，也不在kernel space，肯定是非法访问了。使用48位虚拟地址，则kernel space的高16位都为1，如果一个试图访问kernel space的虚拟地址的高16位不全为1，则可以判断这个访问也是非法的。同理，user space的高16位都为0。这种高位空闲地址被称为canonical。

![%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%2013.png](%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%2013.png)

在内核空间中：0xffff,8800,0000,0000 – 0xffff,c7ff,ffff,ffff 这 64T 直接和物理内存进行映射，0xffff,c900,0000,0000 – 0xffff,e8ff,ffff,ffff 这 32T 用于 vmalloc/ioremap 的地址空间。（这个不确定，因为看了几个博客，描述都不一样。应该是和32bit的原始的情况相似的）

**64位系统中用户空间的映射和32位系统没有太大的差别：**

![%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%2014.png](%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a/Untitled%2014.png)