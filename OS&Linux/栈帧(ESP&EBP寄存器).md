# 栈帧(ESP&EBP寄存器)

**eax, ebx, ecx, edx, esi, edi, ebp, esp** 等都是 **X86 汇编语言中 CPU 上的通用寄存器**的名称，是 **32 位**的寄存器。如果用 C 语言来解释，可以把这些寄存器当作变量看待。 

- EAX 是 "累加器"(accumulator), 它是很多加法乘法指令的缺省寄存器。
- EBX 是 "基地址"(base) 寄存器, 在内存寻址时存放基地址。
- ECX 是计数器 (counter), 是重复(REP) 前缀指令和 LOOP 指令的内定计数器。
- EDX 则总是被用来放整数除法产生的余数
- ESI/EDI 分别叫做 "源 / 目标索引寄存器"(source/destination index), 因为在很多字符串操作指令中, DS:ESI 指向源串, 而 ES:EDI 指向目标串
- **ESP 专门用作堆栈指针，被形象地称为栈顶指针**。从下图可以看到，栈的生长方向是从内存高地址向低地址生长的，所以堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP 也就越来越小。在 32 位平台上，ESP 每次减少 4 字节

![%E6%A0%88%E5%B8%A7(ESP&EBP%E5%AF%84%E5%AD%98%E5%99%A8)%203d93f9ee9e354cc996ee9f5b559e6908/v2-2290195e73159ad0bd364cd3e926c370_1440w.jpg](%E6%A0%88%E5%B8%A7(ESP&EBP%E5%AF%84%E5%AD%98%E5%99%A8)%203d93f9ee9e354cc996ee9f5b559e6908/v2-2290195e73159ad0bd364cd3e926c370_1440w.jpg)

其中，最令人疑惑的应是EBP，EBP 是 " 基址指针 "(BASE POINTER)。 什么是“基址”？这与栈中堆栈帧（stack frame）的概念有关：

> **堆栈帧（stack frame）**（或活动记录（activation record））是一块堆栈保留区域，用于存放被传递的实际参数、子程序的返回值、局部变量以及被保存的寄存器。**实际上堆栈帧就相当于子函数的缓存，当子函数使用的堆栈个数最大时，其所拥有的所有部分构成了这个函数的堆栈帧**。
> 

每一次函数的调用, 都会在调用栈 (call stack) 上维护一个独立的栈帧(stack frame). 每个独立的栈帧一般包括:

- 函数的返回地址和参数
- 临时变量: 包括函数的非静态局部变量以及编译器自动生成的其他临时变量
- 函数调用的上下文栈是从高地址向低地址延伸, 一个函数的栈帧用 ebp 和 esp 这两个寄存器来划定范围. ebp 指向当前的栈帧的底部, esp 始终指向栈帧的顶部; ebp 寄存器又被称为帧指针 (Frame Pointer); esp 寄存器又被称为栈指针 (Stack Pointer);

![Untitled](%E6%A0%88%E5%B8%A7(ESP&EBP%E5%AF%84%E5%AD%98%E5%99%A8)%203d93f9ee9e354cc996ee9f5b559e6908/Untitled.png)

在函数调用的过程中, 有函数的调用者 (caller) 和被调用的函数(callee).

调用者需要知道被调用者函数返回值;

被调用者需要知道传入的参数和返回的地址;

### **函数调用**

函数调用分为以下几步:

- 参数入栈: 将参数按照调用约定 (C 是从右向左) 依次压入系统栈中;
- 返回地址入栈: 将当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行;
- 代码跳转: 处理器将代码区跳转到被调用函数的入口处;
- 栈帧调整: 
1. **将调用者的 ebp 压栈处理**，**保存指向栈底的 ebp 的地址**（方便函数返回之后的现场恢复），此时 esp 指向新的栈顶位置； `push ebp` 
2. 将当前栈帧切换到新栈帧 (将 eps 值装入 ebp，更新栈帧底部), 这时 ebp 指向栈顶，而此时栈顶就是 old ebp `mov ebp, esp`
3. 给新栈帧分配空间 `sub esp, XXX`

### **函数返回**

函数返回分为以下几步:

- 保存被调用函数的返回值到 eax 寄存器中 `mov eax, xxx`
- 恢复 esp 同时回收局部变量空间 `mov ebp, esp`
- 将上一个栈帧底部位置恢复到 ebp `pop ebp`
- 弹出当前栈顶元素, 从栈中取到返回地址, 并跳转到该位置 `ret`

实际上通俗的来说，就相当于调用一个函数的所有相关缓存，**而EBP基址指针的作用就是进入一个函数后将ESP栈顶指针保存下来**，这样就可以通过EBP知道函数在栈中起始的地址。EBP最大的好处就是方便调用临时变量和函数参数，实际上使用ESP也可以，那么为什么要设一个EBP呢？

因为 esp 在函数运行时会不断的变化，所以保**存一个一进入某个函数的 esp 到 ebp 中会方便程序员访问参数和局部变量，而且还方便调试器分析函数调用过程中的堆栈情况**。前面说了，这个 ebp 不是必须要有的，你非要使用 esp 来访问函数参数和局部变量也是可行的，只不过这样会麻烦一些。