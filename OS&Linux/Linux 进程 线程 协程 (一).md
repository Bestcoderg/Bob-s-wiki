# Linux 进程|线程|协程 (一)

## 进程

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动, 进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（**栈、寄存器、虚拟内存、文件句柄**等）比较大，但相对比较稳定安全。相较线程的切换，**进程还多了许多信息的保存，如多级页表。**

在程序启动时，操作系统会给该程序分配一块内存空间，对于程序但看到的是一整块连续的内存空间，称为虚拟内存空间，落实到操作系统内核则是一块一块的内存碎片的东西。为的是节省内核空间，方便对内存管理。

就这片内存空间，又划分为**用户空间与内核空间**，用户空间只用于用户程序的执行，若要执行各种 IO 操作，就会通过系统调用等进入内核空间进行操作。每个进程都有自己的 PID，可以通过 ps 命令查看某个进程的 pid，进入 / proc / 可以查看该进程的详细信息，如 cgroup，进程资源大小等信息。

![Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%B8%80)%200d09f7a806ee49dc900c72539f0996b8/v2-dd59995cec820561819ace49882d6263_r.jpg](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%B8%80)%200d09f7a806ee49dc900c72539f0996b8/v2-dd59995cec820561819ace49882d6263_r.jpg)

## 线程

线程是进程的一个实体, **是 CPU 调度和分派的基本单位,** 它是比进程更小的能独立运行的基本单位. 线程自己基本上不拥有系统资源, 只拥有一点在**运行中必不可少的资源 (如程序计数器, 一组寄存器和栈**), 但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快（3-5us），资源开销较少（1M），但相比进程不够稳定容易丢失数据。

由于多个线程可以共享同一个进程的内存空间，线程的创建不需要额外的虚拟内存空间，**线程之间的切换也就少了如进程切换的切换页表，切换虚拟地址空间此类的巨大开销**。至于进程切换为什么较大，简单理解是因为进程切换要保存的现场太多如寄存器，栈，执行位置等，还需要切换多级页表，而线程切换只需要上下文切换，保存线程执行的上下文即可。线程的的切换只需要保存线程的执行现场 (程序计数器等状态) 保存在该线程的栈里，CPU 把栈指针，指令寄存器的值指向下一个线程。相比之下线程更加轻量级。

可以说进程面向的主要内容是内存分配管理，而线程主要面向的 CPU 调度。

![Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%B8%80)%200d09f7a806ee49dc900c72539f0996b8/v2-1c3fcd78cea7a63572e6f103a5fc64ab_b.jpg](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%B8%80)%200d09f7a806ee49dc900c72539f0996b8/v2-1c3fcd78cea7a63572e6f103a5fc64ab_b.jpg)

## 协程

虽然线程比进程要轻量级，但是每个线程上下文切换依然需要交换 1M 左右的空间，最可怕的是在Linux下，LWP模型的线程非常消耗空间(需要在内核空间申请内核栈，在用户空间申请线程栈)，在高并发场景下非常吃机器内存，比如构建一个 http 服务器，如果一个每来一次请求分配一个线程，请求数暴增容易 OOM，而且线程切换的开销也是不可忽视的。同时，线程的创建与销毁同样是比较大的系统开销，因为是由内核来做的，解决方法也有，可以通过线程池或协程来解决。

**协程是用户态的线程，比线程更加的轻量级，操作系统对其没有感知，之所以没有感知是由于协程处于线程的用户栈能感知的范围，是由用户创建的而非操作系统。协程由于是在用户态来完成上下文切换的，所以切换耗时只有区区 100ns 多一些，比进程切换要高 30 倍。单个协程需要的栈内存也足够小，只需要 2KB。**

协程相较线程核心的不同就是线程的切换是需要内核态与用户态切换的，而协程的处理方式是将上一次寄存器&栈的状态保存下来，等待下次调用时只是替换了CPU核心寄存器&栈的信息，这样的处理方式就更加轻量，不需要内核进行线程的切换和调度

![Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%B8%80)%200d09f7a806ee49dc900c72539f0996b8/v2-074473303f2803fa99f97482f34aba19_b_(1).jpg](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%B8%80)%200d09f7a806ee49dc900c72539f0996b8/v2-074473303f2803fa99f97482f34aba19_b_(1).jpg)

如一个进程可拥有以有多个线程一样，一个线程也可以拥有多个协程。协程之于线程如同线程之于 cpu，拥有自己的协程队列，每个协程拥有自己的栈空间，在协程切换时候只需要保存协程的上下文，开销要比内核态的线程切换要小很多。从图中可以看到，一个CPU核心会在多个线程之间切换，而一个线程又可能会有多个协程。

![Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%B8%80)%200d09f7a806ee49dc900c72539f0996b8/v2-d8168394b74eb2a813eea216a67a75ed_b.jpg](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%B8%80)%200d09f7a806ee49dc900c72539f0996b8/v2-d8168394b74eb2a813eea216a67a75ed_b.jpg)

### GMP模型

如果说到协程就不得不提GO语言了，毕竟协程是GO语言开发的（~~副~~）主产品hhhhhh。GMP模型就是GO对于线程&协程调用的一种模型。**Go 语言对程序员屏蔽了线程的存在，用户不需要手动操作配置线程或者进程**，就可以最大化的利用 cpu 的并发能力。尽管 Go 语言提供了os 包，可以创建进程，调用 os 平台的系统调用。大多数情况下，**使用 Go 单进程加多协程的模式就可以满足业务需求**。 当前的 Go 中，为了充分利用 cpu 的并发能力，也为了减少线程数目较多造成的切换成本，runtime 会努力保证处于运行状态的线程数目不变。环境变量 GOMAXPROCS 决定了 Go 程序中处于运行状态的线程数目 (缺省为 CPU 的核数)。

**G:** 表示 goroutine，每个 goroutine 都有自己的栈空间，定时器，初始化的栈空间在 2k 左右，空间会随着需求增长。

**M:** 抽象化代表内核线程，记录内核线程栈信息，当 goroutine 调度到线程时，使用该 goroutine 自己的栈信息。

**P:** 代表调度器，负责调度 goroutine，维护一个本地 goroutine 队列，M 从 P 上获得 goroutine 并执行，同时还负责部分内存的管理。

从大体看一下 GMP 模型。

![Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%B8%80)%200d09f7a806ee49dc900c72539f0996b8/v2-8e653b564583bdcc8dad669af16396c4_r.jpg](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%B8%80)%200d09f7a806ee49dc900c72539f0996b8/v2-8e653b564583bdcc8dad669af16396c4_r.jpg)

M 代表一个工作线程，在 M 上有一个 P 和 G，P 是绑定到 M 上的，G 是通过 P 的调度获取的，在某一时刻，一个 M 上只有一个 G（g0 除外）。在 P 上拥有一个 G 队列，里面是已经就绪的 G，是可以被调度到线程栈上执行的协程，称为运行队列。

![Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%B8%80)%200d09f7a806ee49dc900c72539f0996b8/v2-d9d8dadcdaf2d3119b5f488d9da7bf2c_r.jpg](Linux%20%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20(%E4%B8%80)%200d09f7a806ee49dc900c72539f0996b8/v2-d9d8dadcdaf2d3119b5f488d9da7bf2c_r.jpg)

接下来看一下程序中 GMP 的分布。

每个进程都有一个全局的 G 队列，也拥有 P 的本地执行队列，同时也有不在运行队列中的 G。如正处于 channel 的阻塞状态的 G，还有脱离 P 绑定在 M 的 (系统调用)G，还有执行结束后进入 P 的 gFree 列表中的 G 等等，接下来列举一下常见的几种状态。