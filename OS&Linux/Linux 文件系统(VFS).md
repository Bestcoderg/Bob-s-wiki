# Linux 文件系统(VFS)

## Linux文件系统

Linux下的文件系统中宏观上主要分为三层：一是上层的文件系统的系统调用；二是虚拟文件系统VFS(Virtual File System)层，三是挂载到VFS中的各种实际文件系统。

VFS是一种软件机制，只存在于内存中，每次系统初始化期间Linux都会先在内存中构造一棵VFS的目录树（也就是源码中的namespace）。VFS主要的作用是对上层应用屏蔽底层不同的调用方法，提供一套统一的调用接口，二是便于对不同的文件系统进行组织管理。因此，VFS其实就是文件系统组织管理中的一个抽象层。

## VFS/虚拟文件系统

Linux 中允许众多不同的文件系统共存，如 ext2, ext3, vfat 等。通过使用同一套文件 I/O 系统 调用即可对 Linux 中的任意文件进行操作而无需考虑其所在的具体文件系统格式；更进一步，对文件的 操作可以跨文件系统而执行。如图 1 所示，我们可以使用 cp 命令从 vfat 文件系统格式的硬盘拷贝数据到 ext3 文件系统格式的硬盘；而这样的操作涉及到两个不同的文件系统。

“一切皆是文件”是 Unix/Linux 的基本哲学之一。不仅普通的文件，目录、字符设备、块设备、 套接字等在 Unix/Linux 中都是以文件被对待；它们虽然类型不同，但是对其提供的却是同一套操作界面。

而虚拟文件系统正是实现上述两点 Linux 特性的关键所在。虚拟文件系统（Virtual File System, 简称 VFS）， 是 Linux 内核中的一个软件层，用于给用户空间的程序提供文件系统接口；同时，它也提供了内核中的一个 抽象功能，允许不同的文件系统共存。系统中所有的文件系统不但依赖 VFS 共存，而且也依靠 VFS 协同工作。

为了能够支持各种实际文件系统，VFS 定义了所有文件系统都支持的基本的、概念上的接口和数据 结构；同时实际文件系统也提供 VFS 所期望的抽象接口和数据结构，将自身的诸如文件、目录等概念在形式 上与VFS的定义保持一致。换句话说，一个实际的文件系统想要被 Linux 支持，就必须提供一个符合VFS标准 的接口，才能与 VFS 协同工作。实际文件系统在统一的接口和数据结构下隐藏了具体的实现细节，所以在VFS 层和内核的其他部分看来，所有文件系统都是相同的。图3显示了VFS在内核中与实际的文件系统的协同关系。

### 目录树相关

### **Directory Entry Cache (dentry cache)**

VFS实现open、stat、chmod等类似的文件系统调用，他们传递一个pathname参数给VFS。VFS根据文件路径pathname搜索directory entry cache（dentry cache或者dcache）获取对应的**dentry**。所以dcache是一个高速目录项缓存，用于映射文件路径和dentry。dentry结构用于优化查询性能，只存在于内存中，不实际存储到磁盘。内存限制，并不是所有dentry都能在缓存命中，当根据pathname找不到对应dentry时，VFS调用lookup接口向底层文件系统查找获取inode信息，以此建立dentry和其对应的inode结构。

### **Inode**

每个dentry通常对应一个inode结构用于描述文件、目录等的基本元数据信息。如果底层是磁盘存储，Inode结构会保存到磁盘。当需要时从磁盘读取到内存中进行缓存。一个inode结构可以被多个dentry指向，如硬链接。对于网络文件系统（分布式文件系统），Inode结构需要通过网络协议获取到缓存中。VFS通过父目录的lookup方法来获取某个文件的inode信息，该方法由底层文件系统实现。一旦获取了inode信息，open,stat等无聊的操作直接从缓存里进行，变得很快。

### **File**

Open一个文件还需要另外一个数据结构：File。File用于表示一个处于Open状态的文件，同一个文件被Open多次对应不同的File结构。应用程序打开文件后对应一个句柄（FD, file descriptor），每个FD都对应到内核的一个File结构，因此File结构直接存放在进程的FD表里，通过FD可以快速获取到File数据结构。VFS实现用户态文件读写关闭操作时，通过用户态的FD来获取对应的File结构，然后调用对应的底层文件系统方法。只要有File结构正在使用，就增加dentry的引用计数，保证dentry和inode结构没有从缓存里删除。

### VFS在内核中与其他的内核模块的协同关系

![Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F(VFS)%20cdeadb7212334135a6db25cdd9fd4c64/Untitled.png](Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F(VFS)%20cdeadb7212334135a6db25cdd9fd4c64/Untitled.png)

![Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F(VFS)%20cdeadb7212334135a6db25cdd9fd4c64/Untitled%201.png](Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F(VFS)%20cdeadb7212334135a6db25cdd9fd4c64/Untitled%201.png)

**1. 硬盘驱动（Device Driver）**

常见的硬盘类型有PATA, SATA和AHCI等，在Linux系统中，对不同硬盘所提供的驱动模块一般都存放在内核目录树drivers/ata中，而对于一般通用的硬盘驱动，也许会直接被编译到内核中，而不会以模块的方式出现，可以通过查看/boot/config-xxx.xxx文件来确认

**2. 通用块设备层（General Block Device Layer）**

这一层的作用，正是解答了上面提出的第一个问题，不同的硬盘驱动，会提供不同的IO接口，内核认为这种杂乱的接口，不利于管理，需要把这些接口抽象一下，形成一个统一的对外接口，这样，不管你是什么硬盘，什么驱动，对外而言，它们所提供的IO接口没什么区别，都一视同仁的被看作块设备来处理。

所以，如果在一层做的任何修改，将会直接影响到所有文件系统，不管是ext3,ext4还是其它文件系统，只要在这一层次做了某种修改，对它们都会产生影响。

**3. 文件系统**

文件系统这一层相信大家都再熟悉不过了，目前大多Linux发行版本默认使用的文件系统一般是ext4，另外，新一代的btrfs也呼之欲出，不管什么样的文件系统，都是由一系列的mkfs.xxx命令来创建，如：

```bash
mkfs.ext4 /dev/sda
mkfs.btrfs /dev/sdb
```

内核所支持的文件系统类型，可以通过内核目录树 fs 目录中的内容来查看。

**4. 虚拟文件系统(Virtual File System)**

Virtual File System这一层，正是用来解决上面提出的第二个问题，试想，当我们通过mkfs.xxx系列命令创建了很多不同的文件系统，但这些文件系统都有各自的API接口，而用户想要的是，不管你是什么API，他们只关心mount/umount，或open/close等操作。

所以，VFS就把这些不同的文件系统做一个抽象，提供统一的API访问接口，这样，用户空间就不用关心不同文件系统中不一样的API了。VFS所提供的这些统一的API，再经过System Call包装一下，用户空间就可以经过SCI的系统调用来操作不同的文件系统。

VFS所提供的常用API有：mount()、umount()、open()、close()、mkdir()

Linux启动时，第一个必须挂载的是根文件系统；若系统不能从指定设备上挂载根文件系统，则系统会出错而退出启动。之后可以自动或手动挂载其他的文件系统。因此，一个系统中可以同时存在不同的文件系统。　不同的文件系统类型有不同的特点，因而根据存储设备的硬件特性、系统需求等有不同的应用场合。在嵌入式Linux应用中，主要的存储设备为RAM(DRAM, SDRAM)和ROM(常采用FLASH存储器)，常用的基于存储设备的文件系统类型包括：jffs2, yaffs, cramfs, romfs, ramdisk, ramfs/tmpfs等。

![Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F(VFS)%20cdeadb7212334135a6db25cdd9fd4c64/Untitled%202.png](Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F(VFS)%20cdeadb7212334135a6db25cdd9fd4c64/Untitled%202.png)

## 文件存储结构

介绍文件存储结构前先来看看文件系统如何划分磁盘，创建一个文件、目录、链接的过程。

![Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F(VFS)%20cdeadb7212334135a6db25cdd9fd4c64/Untitled%203.png](Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F(VFS)%20cdeadb7212334135a6db25cdd9fd4c64/Untitled%203.png)

**1. 超级块**

文件系统中第一个块被称为超级块。这个块存放文件系统本身的结构信息。比如，超级块记录了每个区域的大小，超级块也存放未被使用的磁盘块的信息。

**2. I-切点表**

超级块的下一个部分就是i-节点表。每个i-节点就是一个对应一个文件/目录的结构，这个结构它包含了一个文件的长度、创建及修改时间、权限、所属关系、磁盘中的位置等信息。一个文件系统维护了一个索引节点的数组，每个文件或目录都与索引节点数组中的唯一一个元素对应。系统给每个索引节点分配了一个号码，也就是该节点在数组中的索引号，称为索引节点号

**3. 数据区**

文件系统的第3个部分是数据区。文件的内容保存在这个区域。磁盘上所有块的大小都一样。如果文件包含了超过一个块的内容，则文件内容会存放在多个磁盘块中。一个较大的文件很容易分布上千个独产的磁盘块中。

Linux正统的文件系统(如ext2、ext3)一个文件由目录项、inode和数据块组成。目录项:包括文件名和inode节点号。Inode：又称文件索引节点，是文件基本信息的存放地和数据块指针存放地。数据块：文件的具体内容存放地。Linux正统的文件系统(如ext2、3等)将硬盘分区时会划分出目录块、inode Table区块和data block数据区域。一个文件由一个目录项、inode和数据区域块组成。Inode包含文件的属性(如读写属性、owner等，以及指向数据块的指针)，数据区域块则是文件内容。当查看某个文件时，会先从inode table中查出文件属性及数据存放点，再从数据块中读取数据。文件存储结构大概如下：

![Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F(VFS)%20cdeadb7212334135a6db25cdd9fd4c64/Untitled%204.png](Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F(VFS)%20cdeadb7212334135a6db25cdd9fd4c64/Untitled%204.png)

目录项结构:

![https://images0.cnblogs.com/blog2015/710103/201504/231653020936547.png](https://images0.cnblogs.com/blog2015/710103/201504/231653020936547.png)

其中文件的inode结构如下（inode里所包含的文件信息可以通过stat filename查看得到）：

![https://images0.cnblogs.com/blog2015/710103/201504/231653367033107.png](https://images0.cnblogs.com/blog2015/710103/201504/231653367033107.png)

## 创建一个文件/目录的过程

### **创建一个文件**

我们从前面可以知道文件的内容和属性是分开存放的，那么又是如何管理它们的呢?现在我们以创建一个文件为例来讲解。在命令行输入命令：

```bash
$ who > userlist
```

当完成这个命令时，文件系统中增加了一个存放命令who输出内容的新文件userlist。那么这整个过程到底是怎么回事呢？文件主要有属性、内容以及文件名三项。内核将文件内容存放在数据区，文件属性存放在i-节点，文件名存放在目录中。创建成功一个文件主要有以下四个步骤：

**存储属性**

也就是文件属性的存储，内核先找到一块空的i-节点。例如，内核找到i-节点号921130。内核把文件的信息记录其中。如文件的大小、文件所有者、和创建时间等。

**存储数据**

即文件内容的存储，由于该文件需要3个数据块。因此内核从自由块的列表中找到3个自由块。如600、200、992，内核缓冲区的第一块数据复制到块600，第二和第三分别复制到922和600.

**记录分配情况**

数据保存到了三个数据块中，所以必须要记录起来，以后再找到正确的数据。分配情况记录在文件的i-节点中的磁盘序号列表里，这3个编号分别放在最开始的3个位置。

**添加文件名到目录**

新文件的名字是userlist 内核将文件的入口(47,userlist)添加到目录文件里。文件名和i-节点号之间的对应关系将文件名和文件和文件的内容属性连接起来，找到文件名就找到文件的i-节点号，通过i-节点号就能找到文件的属性和内容。

### **创建一个目录**

前面说了创建一个文件的大概过程，也了解文件内容、属性以及入口的保存方式，那么创建一个目录时又是怎么回事呢？我现在test目录使用命令mkdir 新增一个子目录child：从用户的角度看，目录child是目录test的一个子目录，那么在系统中这层关系是怎么实现的呢？实际上test目录包含一个指向子目录child的i-节点的链接，原理跟普通文件一样，因为目录也是文件。目录其实也是文件，只是它的内容比较特殊。所以它的创建过程和文件创建过程一样，只是第二步写的内容不同。

1. 系统找到空闲的i-节点号887220,写入目录的属性
2. 找到空闲的数据块1002来存储目录的内容，只是目录的内容比较特殊，包含文件名字列表，列表一般包含两个部分：i-节点号和文件名，这个列表其实也就是文件的入口，新建的目录至少包含三个目录”.”和”..”其中”.”指向自己，”..”指向上级目录，我们可以通过比较对应的i-节点号来验证,887270 对应着上级目录中的child对应的i-节点号
3. 记录分配情况。这个和创建文件完全一样
4. 添加目录的入口到父目录，即在父目录中的child入口

一般都说文件存放在某个目录中，其实目录中存入的只是文件在i-节点表的入口，而文件的内容则存储在数据区。我们一般会说“文件userlist在目录test中”,其实这意味着目录test中有一个指向i-节点921130的链接，这个链接所附加的文件名为userlist,这也可以这样理解：目录包含的是文件的引用，每个引用被称为链接。文件的内容存储在数据块。文件的属性被记录在一个被称为i-节点的结构中。I-节点的编号和文件名关联起来存在目录中。注意：其中“.”表示是当前目录。而“..”是当前目录的父目录。但也有特殊情况：如我们查看根目录/的情况:发现“.”和“..”都指向i-节点2。实际上当我们用mkfs创建一个文件系统时，mkfs都会将根目录的父目录指向自己。所以根目录下.和..指向同一个i-节点也不奇怪了。

## 基于VFS的文件I/O

在深入sys_open()和sys_read()之前，我们先概览下调用sys_read()的上下文。图7描述了从用户空间的read()调用到数据从 磁盘读出的整个流程。当在用户应用程序调用文件I/O read()操作时，系统调用sys_read()被激发，sys_read()找到文件所在的具体文件 系统，把控制权传给该文件系统，最后由具体文件系统与物理介质交互，从介质中读出数据。

![Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F(VFS)%20cdeadb7212334135a6db25cdd9fd4c64/Untitled%205.png](Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F(VFS)%20cdeadb7212334135a6db25cdd9fd4c64/Untitled%205.png)

## 总结

VFS即虚拟文件系统是Linux文件系统中的一个抽象软件层；因为它的支持，众多不同的实际文件系统才能在Linux中共存，跨文件系统操作才能实现。VFS借助它四个主要的数据结构即超级块、索引节点、目录项和文件对象以及一些辅助的数据结构，向Linux中不管是普通的文件还是目录、设备、套接字等都提供同样的操作界面，如打开、读写、关闭等。只有当把控制权传给实际的文件系统时，实际的文件系统才会做出区分，对不同的文件类型执行不同的操作。由此可见，正是有了VFS的存在，跨文件系统操作才能执行，Unix/Linux中的“一切皆是文件”的口号才能够得以实现。