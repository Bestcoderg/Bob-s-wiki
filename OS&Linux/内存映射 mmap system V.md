# 内存映射 mmap/system V

## mmap 基础概念

mmap顾名思义是一种内存的映射方法，即将一个**文件或者其它对象映射到进程的地址空间**，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的**映射**关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用 read,write 等系统调用函数。在进**程间共享内存，实时编译JIT**等技术的实现过程中，都有应用到mmap。

![%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%20mmap%20system%20V%20525b256cfb2e457c86c5ac99d291aff7/Untitled.png](%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%20mmap%20system%20V%20525b256cfb2e457c86c5ac99d291aff7/Untitled.png)

由上图可以看出，进程的虚拟地址空间，由多个虚拟内存区域构成。虚拟内存区域是进程的虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的 text 数据段（代码段）、初始数据段、BSS 数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。而为内存映射服务的地址空间处在堆栈之间的空余部分。

linux 内核使用 vm_area_struct 结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个 vm_area_struct 结构来分别表示不同类型的虚拟内存区域。各个 vm_area_struct 结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：

![%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%20mmap%20system%20V%20525b256cfb2e457c86c5ac99d291aff7/Untitled%201.png](%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%20mmap%20system%20V%20525b256cfb2e457c86c5ac99d291aff7/Untitled%201.png)

m_area_struct 结构中包含区域起始和终止地址以及其他相关信息，同时也包含一个 vm_ops 指针，其内部可引出所有针对这个区域可以使用的系统调用函数。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从 vm_area_struct 中获得。mmap 函数就是要创建一个新的 vm_area_struct 结构，并将其与文件的物理磁盘地址相连。

### mmap 如何映射内存

mmap 内存映射的实现过程，总的来说可以分为三个阶段：

**进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域**

- 进程在用户空间调用库函数 mmap，原型：void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
- 在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址
- 为此虚拟区分配一个 vm_area_struct 结构，接着对这个结构的各个域进行了初始化
- 将新建的虚拟区结构（vm_area_struct）**插入进程的虚拟地址区域链表或树中**

**调用内核空间的系统调用函数 mmap（不同于用户空间函数）**

（**实现文件物理地址和进程虚拟地址的一一映射关系）**

- 为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核 “已打开文件集” 中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。
- 通过该文件的文件结构体，链接到 file_operations 模块，**调用内核函数 mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)**，不同于用户空间库函数。
- 内核 mmap 函数通过虚拟文件系统 inode 模块定位到文件磁盘物理地址。
- 通过 remap_pfn_range 函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中

**进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝**

- 进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。
- 缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。
- 调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用 nopage 函数把所缺的页从磁盘装入到主存中。
- 之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。

注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用 **msync() 来强制同步,** 这样所写的内容就能立即保存到文件里了。

### mmap 和常规文件操作的区别

常规文件系统操作（调用 read/fread 等类函数）中，函数的调用过程：

- 进程发起读文件请求。
- 内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的 inode。
- inode 在 address_space 上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。
- 如果不存在，则通过 inode 定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。

总结来说，**常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制**。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。**这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。**写操作也是一样，待写入的 buffer 在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。

[页缓存&内存组织方式](%E9%A1%B5%E7%BC%93%E5%AD%98&%E5%86%85%E5%AD%98%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%20351ab7a6eb64447a9ed2b9178098c8ae.md)

而使用 mmap 操作文件中，创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射这两步，没有任何文件拷贝操作。而之后访问数据时发现内存中并无数据而发起的缺页异常过程，可以通过已经建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。

**总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而 mmap 操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。**说白了，mmap 的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此 mmap 效率更高。详细可以看：[虚拟内存(内核空间&用户空间)](%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98(%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)%20919e35135f674d998286e9d031aa158a.md) 

**总结一下mmap的优点：**

- 对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代 I/O 读写，提高了文件读取效率。
- 实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。
- 提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。
  
    同时，如果进程 A 和进程 B 都映射了区域 C，当 A 第一次读取 C 时通过缺页从磁盘复制文件页到内存中；但当 B 再读 C 的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。
    
- 可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件 I/O 操作，极大影响效率。这个问题可以通过 mmap 映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap 都可以发挥其功效。

### mmap 函数原型

```cpp
void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset);
```

start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址。

length：映射区的长度。//长度单位是 以字节为单位，不足一内存页按一内存页处理

prot：期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过or运算合理地组合在一起

```cpp
PROT_EXEC //页内容可以被执行
PROT_READ //页内容可以被读取
PROT_WRITE //页可以被写入
PROT_NONE //页不可访问
```

flags：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体

```cpp
MAP_FIXED //使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。
MAP_SHARED //与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到msync()或者被调用，文件实际上不会被更新。
MAP_PRIVATE //建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。
MAP_DENYWRITE //这个标志被忽略。
MAP_EXECUTABLE //同上
MAP_NORESERVE //不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时[内存不足]，对映射区的修改会引起段违例信号。
MAP_LOCKED //锁定映射区的页面，从而防止页面被交换出内存。
MAP_GROWSDOWN //用于堆栈，告诉[内核]VM系统，映射区可以向下扩展。
MAP_ANONYMOUS //匿名映射，映射区不与任何文件关联。
MAP_ANON //MAP_ANONYMOUS的别称，不再被使用。
MAP_FILE //兼容标志，被忽略。
MAP_32BIT //将映射区放在进程[地址空间]的低2GB，MAP_FIXED指定时会被忽略。当前这个标志只在x86-64平台上得到支持。
MAP_POPULATE //为文件映射通过预读的方式准备好页表。随后对映射区的访问不会被页违例阻塞。
MAP_NONBLOCK //仅和MAP_POPULATE一起使用时才有意义。不执行预读，只为已存在于内存中的页面建立[页表]入口。
```

fd：有效的[文件描述词](https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%8D)。一般是由[open](https://baike.baidu.com/item/open/13009226)()函数返回，**其值也可以设置为-1，此时需要指定flags参数中的MAP_ANON,表明进行的是匿名映射。**

offset：被映射对象内容的起点。

### mmap 使用细节

- 使用 mmap 需要注意的一个关键点是，mmap 映射区域大小必须是物理页大小 (page_size) 的整倍数（32 位系统中通常是 4k 字节）。原因是，内存的最小粒度是页，而进程虚拟地址空间和内存的映射也是以页为单位。为了匹配内存的操作，mmap 从磁盘到虚拟地址空间的映射也必须是页。
- 内核可以跟踪被内存映射的底层对象（文件）的大小，进程可以合法的访问在当前文件大小以内又在内存映射区以内的那些字节。也就是说，如果文件的大小一直在扩张，只要在映射区域范围内的数据，进程都可以合法得到，这和映射建立时文件的大小无关。具体情形参见 “情形三”。
- 映射建立之后，即使文件关闭，映射依然存在。因为映射的是磁盘的地址，不是文件本身，和文件句柄无关。同时可用于进程间通信的有效地址空间不完全受限于被映射文件的大小，因为是按页映射。

在上面的知识前提下，我们下面看看如果大小不是页的整倍数的具体情况：

**情形一：一个文件的大小是 5000 字节，mmap 函数从一个文件的起始位置开始，映射 5000 字节到虚拟内存中。**

分析：因为单位物理页面的大小是 4096 字节，虽然被映射的文件只有 5000 字节，但是对应到进程虚拟地址区域的大小需要满足整页大小，因此 mmap 函数执行后，实际映射到虚拟内存区域 8192 个 字节，5000~8191 的字节部分用零填充。映射后的对应关系如下图所示：

![%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%20mmap%20system%20V%20525b256cfb2e457c86c5ac99d291aff7/Untitled%202.png](%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%20mmap%20system%20V%20525b256cfb2e457c86c5ac99d291aff7/Untitled%202.png)

此时：

（1）读 / 写前 5000 个字节（0~4999），会返回操作文件内容。

（2）**读字节 5000~8191 时，结果全为 0。写 5000~8191 时，进程不会报错，但是所写的内容不会写入原文件中** 。

（3）读 / 写 8192 以外的磁盘部分，会返回一个 SIGSECV 错误。

**情形二：一个文件的大小是 5000 字节，mmap 函数从一个文件的起始位置开始，映射 15000 字节到虚拟内存中，即映射大小超过了原始文件的大小。**

分析：由于文件的大小是 5000 字节，和情形一一样，其对应的两个物理页。那么这两个物理页都是合法可以读写的，只是超出 5000 的部分不会体现在原文件中。由于程序要求映射 15000 字节，而文件只占两个物理页，因此 8192 字节~ 15000 字节都不能读写，操作时会返回异常。如下图所示：

![%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%20mmap%20system%20V%20525b256cfb2e457c86c5ac99d291aff7/Untitled%203.png](%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%20mmap%20system%20V%20525b256cfb2e457c86c5ac99d291aff7/Untitled%203.png)

此时：

（1）进程可以正常读 / 写被映射的前 5000 字节 (0~4999)，写操作的改动会在一定时间后反映在原文件中。

（2）对于 5000~8191 字节，进程可以进行读写过程，不会报错。但是内容在写入前均为 0，另外，写入后不会反映在文件中。

（3）对于 8192~14999 字节，进程不能对其进行读写，会报 SIGBUS 错误。

（4）对于 15000 以外的字节，进程不能对其读写，会引发 SIGSEGV 错误。

**情形三：一个文件初始大小为 0，使用 mmap 操作映射了 1000*4K 的大小，即 1000 个物理页大约 4M 字节空间，mmap 返回指针 ptr。**

分析：如果在映射建立之初，就对文件进行读写操作，由于文件大小为 0，并没有合法的物理页对应，如同情形二一样，会返回 SIGBUS 错误。

但是如果，每次操作 ptr 读写前，先增加文件的大小，那么 ptr 在文件大小内部的操作就是合法的。例如，文件扩充 4096 字节，ptr 就能操作 ptr ~ [(char)ptr + 4095] 的空间。只要文件扩充的范围在 1000 个物理页（映射范围）内，ptr 都可以对应操作相同的大小。

这样，方便**随时扩充文件空间，随时写入文件**，不造成空间浪费。

### mmap的两种方式映射方式

根据 mmap 映射是否与文件相关联，可以将 Linux 内核中映射可以分为两种：**匿名映射和文件映射。**

- **匿名映射**：没有映射对应的相关文件，这种映射的内存区域的内容会被初始化为 0。
- **文件映射**：映射和实际文件相关联，通常是把文件的内容映射到进程地址空间，这样应用程序就可以像操作进程地址空间一样读写文件。

根据文件关联性、映射区域是否共享这两个属性，mmap 的映射类型，又可以分为如下 4 种：

![%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%20mmap%20system%20V%20525b256cfb2e457c86c5ac99d291aff7/Untitled%204.png](%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%20mmap%20system%20V%20525b256cfb2e457c86c5ac99d291aff7/Untitled%204.png)

- **私有匿名映射**
  
    当使用参数 fd=-1 且 **flags=MAP_ANONYMOUS | MAP_PRIVATE** 时，创建的 mmap 映射是私有匿名映射。私有匿名映射最常见的用途是在 glibc 分配大块内存中，当需要的分配的内存大于 MMAP_THREASHOLD(128KB) 时**，glibc 会默认使用 mmap 代替 brk 来分配内存。**实际上，**在JIT实现实时编译的过程中，便使用匿名内存映射的方式**，实现了开辟可执行内存的效果。[编译器(JIT&AOT)与解释器](%E7%BC%96%E8%AF%91%E5%99%A8(JIT&AOT)%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%20b736c805b8e74e9b920ddcc805b931da.md) 
    
- **共享匿名映射**
  
    当使用参数 fd=-1 且 flags=MAP_ANONYMOUS | MAP_SHARED 时，创建的 mmap 映射是共享匿名映射。共享匿名映射让相关进程共享一块内存区域，**通常用于父子进程的之间通信。**
    
- **私有文件映射**
  
    私有文件映射时 flags 的标志位被设置为 MAP_PRIVATE，那么就会创建私有文件映射。**私有文件映射的最常用的场景是加载动态共享库。**
    
    **关于加载动态库的一点思考：多进程使用时，动态库在物理内存中有几份：**
    
    结论是只有一份，这是为什么呢？由于我们调用mmap开辟了虚拟内存后，只是建立了虚拟内存到文件地址的映射，而真正在通过虚拟内存访问物理内存时，会先通过页表去查询这块文件地址是否已经加载入了物理内存，如果加载了会直接取。综上，多进程同时使用一个动态链接库，在物理内存中只会有一份数据。
    
- **共享文件映射**
  
    创建文件映射时 flags 的标志位被设置为 MAP_SHARED，那么就会创建共享文件映射。如果 prot 参数指定了 PROT_WRITE，那么打开文件需要制定 O_RDWR 标志位。共享文件映射通常有如下场景：
    
    - **读写文件：**把文件内容映射到进程地址空间，同时对映射的内容做了修改，内核的回写机制（writeback）最终会把修改的内容同步到磁盘中。
    - **进程间通信：**进程之间的进程地址空间相互隔离，一个进程不能访问到另外一个进程的地址空间。如果多个进程都同时映射到一个相同的文件，就实现了多进程间的共享内存的通信。如果一个进程对映射内容做了修改，那么另外的进程是可以看到的

## System V

linux 中的两种共享内存。一种是存储映射 I/O（mmap 函数）另一种是我们的 IPC 通信 System V 版本的共享内存。

### System **V 共享内存原理**

进程间需要共享的数据被放在一个叫做 IPC 共享内存区域的地方，所有需要访问该共享区域的进程都要把该共享区域映射到本进程的地址空间中去。系统 V 共享内存通过 shmget 获得或创建一个 IPC 共享内存区域，并返回相应的标识符。内核在保证 shmget 获得或创建一个共享内存区，初始化该共享内存区相应的 shmid_kernel 结构注同时，还将在特殊文件系统 shm 中，创建并打开一个同名文件，并在内存中建立起该文件的相应 dentry 及 inode 结构，**新打开的文件不属于任何一个进程（任何进程都可以访问该共享内存区）**。所有这一切都是系统调用 shmget 完成的。

在创建了一个共享内存区域后，还要将它映射到进程地址空间，系统调用 shmat() 完成此项功能。由于在调用 shmget() 时，已经创建了文件系统 shm 中的一个同名文件与共享内存区域相对应，因此，**调用 shmat() 的过程相当于映射文件系统 shm 中的同名文件过程**，原理与 mmap() 大同小异。

- 系统 V 共享内存中的数据，从来不写入到实际磁盘文件中去；而通过 mmap() 映射普通文件实现的共享内存通信可以指定何时将数据写入磁盘文件中。 注：前面讲到，系统 V 共享内存机制实际是通过映射特殊文件系统 shm 中的文件实现的，文件系统 shm 的安装点在交换分区上，系统重新引导后，所有的内容都丢失。
- 系统 V 共享内存是随内核持续的，**即使所有访问共享内存的进程都已经正常终止，共享内存区仍然存在（除非显式删除共享内存）**，在内核重新引导之前，对该共享内存区域的任何改写操作都将一直保留。
- 通过调用 mmap() 映射普通文件进行进程间通信时，一定要注意考虑进程何时终止对通信的影响。而通过系统 V 共享内存实现通信的进程则不然。 注：这里没有给出 shmctl 的使用范例，原理与消息队列大同小异

共享内存允许两个或多个进程共享一给定的存储区，因为数据不需要来回复制，所以是最快的一种进程间通信机制。共享内存可以通过 mmap() 映射普通文件（特殊情况下还可以采用匿名映射）机制实现，也可以通过系统 V 共享内存机制实现。应用接口和原理很简单，内部机制复杂。为了实现更安全通信，往往还与信号等同步机制共同使用

### **mmap shmat 区别**

1. mmap 是在磁盘上建立一个文件，每个进程地址空间中开辟出一块空间进行映射。而对于 shm 而言，shm 每个进程最终会映射到同一块物理内存。shm 保存在物理内存，这样读写的速度要比磁盘要快，但是存储量不是特别大。
2. 相对于 shm 来说，mmap 更加简单，调用更加方便，所以这也是大家都喜欢用的原因。
3. sysv shm 是持久化的，除非被一个进程明确的删除，否则它始终存在于内存里，直到系统关机；mmap 映射的内存在不是持久化的，如果进程关闭，映射随即失效，除非事先已经映射到了一个文件上

由于 shmat 共享内存是持久化的，所以有时为了防止进程 down 掉后，内存没有回收，一般会在 create attach 后就 IPC_RMID 删除内存，当然所有的进程 detattch 这块内存后， 内存才会被回收（RO踩坑的点，共享内存开出来后，进程core dump了，没有回收共享内存。第二次起进程又用了那块共享内存。）