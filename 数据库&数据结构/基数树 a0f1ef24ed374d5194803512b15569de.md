# 基数树

在计算机科学中，基数树，或称压缩前缀树，是一种更节省空间的Trie（前缀树）。对于基数树的每个节点，如果该节点是确定的子树的话，就和父节点合并。能以潜在的稀疏性为代价降低基数树的深度。

![%E5%9F%BA%E6%95%B0%E6%A0%91%20a0f1ef24ed374d5194803512b15569de/Untitled.png](%E5%9F%BA%E6%95%B0%E6%A0%91%20a0f1ef24ed374d5194803512b15569de/Untitled.png)

**radix Tree(基数树) 其实就差不多是传统的二叉搜索树，**只是在寻找方式上，利用比如一个 unsigned int 的类型的每一个比特位作为树节点的判断。

可以这样说，比如一个数 1000101010101010010101010010101010，那么按照 Radix 树的插入就是在根节点，如果遇到 0，就指向左节点，如果遇到 1 就指向右节点，在插入过程中构造树节点，在删除过程中删除树节点。如果觉得太多的调用 Malloc 的话，可以采用池化技术，预先分配多个节点（**使用一个比特位判断，会使树的高度过高，非叶节点过多。故在实际应用中，我们一般是使用多个比特位作为树节点的判断，但多比特位会使节点的子节点槽变多，增大节点的体积**，一般选用 2 个或 4 个比特位作为树节点即可）

![%E5%9F%BA%E6%95%B0%E6%A0%91%20a0f1ef24ed374d5194803512b15569de/Untitled%201.png](%E5%9F%BA%E6%95%B0%E6%A0%91%20a0f1ef24ed374d5194803512b15569de/Untitled%201.png)

Radix 树与 Trie 树（字典树）的思想有点类似，甚至可以把 Trie 树看为一个基为 26 的 Radix 树。（也可以把 Radix 树看做是 Tire 树的变异）

### Radix 树在 Linux 中的应用：

Linux 基数树（radix tree）是将 long 整数键值与指针相关联的机制，它存储有效率，并且可快速查询，用于整数值与指针的映射（如：IDR 机制）、内存管理等。**IDR（ID Radix）机制**是将对象的 **身份鉴别号整数值 ID 与对象指针建立关联表**，完成从 ID 与指针之间的相互转换。IDR 机制使用 radix 树状结构作为由 id 进行索引获取指针的稀疏数组，通过使用位图可以快速分配新的 ID，IDR 机制避免了使用固定尺寸的数组存放指针。IDR 机制的 API 函数在 lib/idr.c 中实现。

Linux radix 树最广泛的用途是用于 **内存管理**，结构 address_space **通过 radix 树跟踪绑定到地址映射上的核心页**，该 radix 树允许内存管理代码快速查找标识为 dirty 或 writeback 的页(**将一些标志与物理页的id组合为key，这样通过这些标志，就可以在基数树上快速区分**)。其使用的是数据类型 unsigned long 的固定长度输入的版本。每级代表了输入空间固定位数。Linux radix 树的 API 函数在 lib/radix-tree.c 中实现。（把页指针和描述页状态的结构映射起来，使能快速查询一个页的信息。）Linux 内核利用 radix 树在文件内偏移快速定位文件缓存页。 Linux(2.6.7) 内核中的分叉为 64(2^6)，树高为 6(64 位系统) 或者 11(32 位系统)，用来快速定位 32 位或者 64 位偏移，radix tree 中的每一个叶子节点指向文件内相应偏移所对应的 Cache 项。