# 优先搜索树 PST

## 优先搜索树

在了解优先搜索树之前，让我们首先了解一下区间集合与空间点集之间的转化，以及几种树形结构的应用特点吧。感谢PST_part1，打开了我对树形结构的思路。

[PST_part1.pdf](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/PST_part1.pdf)

[PST_part2.pdf](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/PST_part2.pdf)

[PST优先搜索树原理及在Linux内核中的应用浅析_徐炜.pdf](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/PST%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9C%A8Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%85%E6%9E%90_%E5%BE%90%E7%82%9C.pdf)

### 区间集合与空间点集

首先，我们通过问题引出思考，假设我们在一段一维区间 *l* 上给出了13个区间 *a~n* 如图所示。那么假设我们又给出了一段区间 X ，如何求出 *a~n* 中包含区间 X 的、被区间 X 包含的、以及与区间 X 相交的线段？

![%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled.png](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled.png)

实际上为了解决这个问题，我们可以将区间集合映射为一个空间点集，如图。在获得线段区间对应的空间点集后，实际上这个问题的答案初见苗头。我们可以看到对于 *h* 区间，被 *h* 区间包含的几个区间在空间点集中，在 *h* 区间对应的空间点集 H 的两条垂直射线下面，即 *i、j、g、k*。

![%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%201.png](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%201.png)

但即使如此，答案仿佛还是不够明确。那么接下来让我们再将我们空间点集的坐标轴旋转一下：

![%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%202.png](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%202.png)

![%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%203.png](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%203.png)

![%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%204.png](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%204.png)

再旋转坐标轴后，答案就显得非常明显了，在 *Figure 6* 中我们可以看到，假设我们以 *g* 对应的空间点画一个十字的坐标，则区域1被G包含，区域2与G相交，区域3包含了区域G。综上可知，我们在解决区间的问题时，我们可以将区间映射为空间点集来求解。

### 树形结构能做什么？

在正式开始解析PST前，我们先来看看我们常见的几种树形结构究竟能实现多么神奇的功能吧。在上一个篇章中，我们从区间“进化”为了空间点集，现在我们再将这些散乱点“进化”为“树”吧！

![%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%205.png](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%205.png)

首先，我们看两个问题：(a)找出空间点集中X-coordinate介于两条竖直的线之间的点集。(b)找出空间点集中Y_coordinate在平行线之上的点集。

对于问题(a)，我们可以将点集通过X-coordinate组成一颗二叉搜索树来解决这个问题，实际上的效率要高于遍历。

对于问题(b)，我们可以将点集通过Y-coordinate组成一个最大堆来解决这个问题，效率同样高于遍历。

而我们的主角：优先搜索树正是堆与基数树(二叉搜索树+)的结合。[基数树](%E5%9F%BA%E6%95%B0%E6%A0%91%20a0f1ef24ed374d5194803512b15569de.md) 

### 构建一棵优先搜索树

对于一个空间点集 *S* （区间集合的映射），我们构建一棵优先搜索树：

- 如果 S 为空就返回
- 找到 S 中Y-coordinate最大的点 P ，作为根节点
- 将剩下的点用一条线 X(P) 分割为两个集合，X(P)尽量保证两边的点数量一致
- 对于新生成的两个集合，再取出其中Y-coordinate最大的点，并由P指向这两个点，重复上面的操作

![%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%206.png](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%206.png)

![%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%207.png](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%207.png)

最后我们得到了一棵树，这棵树对于Y轴来说，是一个最大堆的形式。对于X轴来说，实际上由于我们取得了X(P)，最后得到了二叉搜索树的效果。

### 查询优先搜索树

假设我们现在获得了一棵优先搜索树，给出一个查询区间： x'，x'' 和 y' ，现在我们希望优先搜索树中X-coordinate介于 x' 与 x'' 之间，Y-coordinate 大于 y‘ 的点，以下是一棵优先搜索树的查询流程：

- 设R为树根节点，x为它的 X-coordinate，y为它的 Y-coordinate, X(R)为 R的子树节点的分割线
- 首先比较 y 与 y' ，如果 y < y' 则返回 null (因为PST具有堆的性质)
- 在 y≤y' 时， 如果 x'<x<x''则代表这个点符合条件，将这个点标记下来
- 如果 x' < X(R) , 获取左子树并重复上面的操作
- 如果 X(R) < x'' ，获取右子树并重复上面的操作

![%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%208.png](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%208.png)

## 动态优先搜索树

前面我们讲到了优先搜索树的构建，但是如果真想要将其应用到系统中显然对于树的插入、删除等操作是必不可少的。那么如何构建一棵支持动态增删的优先搜索树呢？首先我们来看一下一棵动态搜索树的树形：

![%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%209.png](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%209.png)

我们可以看到这棵动态优先搜索树与之前的优先搜索树最大的区别就在于，只有叶子节点直接存储数据，或是说只有叶子节点直接指向数据，树节点不直接存储数据。同时，所有的叶子节点从左到右的顺序与叶子节点对应的数据的X-coordinate的顺序一致。非叶子节点存储了以此非叶子节点为根节点的子树中 Y-coordiante 最大的叶子节点对应的数据(注意不是真的数据，而是一个占位符)。非叶子节点与叶子节点的区别是动态优先搜索树与优先搜索树主要的区别。

### 动态优先搜索树的查询

动态优先搜索树的查询与原来比较相似，如还是在原来的空间点集上进行同样的范围查询（x' x'' y'）

- 如果遍历到的节点为空就返回
- 比较当前遍历到的节点的 Y-coordinate 与 y' ，如果 Y-coordinate < y' 就返回
- 如果 x' ≤ X-coordinate ≤ x'' 说明当前遍历的点符合条件，标记此点。遍历左右子树
- 如果 X-coordinate < x' 则遍历当前节点的右子树
- 如果 X-coordinate > x'' 则遍历当前节点左子树

![%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%2010.png](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%2010.png)

### 构建一棵优先搜索树

对于一个点集S，构建一棵优先搜索树：

- 首先将所有点根据X-coordinate排序
- 将点两两比较，Y-coordiante 大的点的占位符作为树节点
- 对于每一层节点都按照这个规则进行

### 插入一个点

如下图，我们在原来的点集中插入一个 c' ：

![%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%2011.png](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%2011.png)

- 首先，由于我们维护了 X-coordinate ，我们通过 c' 的 x坐标，一直向下递归（当前节点X-coordinate 大于x'就递归左子树，反之递归右子树），直到找到一个对应的叶子节点。此时，我们在我们找到的叶子节点的位置，添加一个新的非叶子节点(internal node)，然后将c’与原来的叶子节点挂到这个非叶子节点上。注意，此时新增的非叶子节点还没有对应的叶子节点，或者说此时树上的非叶子节点的值还没有维护。
- 第二步我们需要维护树上非叶子节点使整棵树依旧能够保持优先搜索树的性质。我们依旧将 c' 从树根开始向下递归，不过每次递归到一个树节点时，我们需要将 c' 的 Y-coordiante 与当前节点比较，如果 当前节点的 Y-coordiante 大于 c‘ 的 Y-coordinate 则继续向下递归，如果当前节点的 Y-coordinate 小于 c' 的 Y-coordinate 则将当前节点替换为 c’ 的占位符(叶子节点对应的非叶子节点被称为占位符)然后将原来的节点向下传递，按照与以上相同的规则维护路径上所有的占位符。

![%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%2012.png](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%2012.png)

![%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%2013.png](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%2013.png)

![%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%2014.png](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%2014.png)

### 动态优先搜索树的旋转

现在，我们知道了如何构建一棵优先搜索树，如何查找，如何插入。那么为了让我们的搜索树维持一个良好的效率，树的旋转是比不可少的，接下来会讲讲动态优先搜索树的左旋，其他的几种旋转大同小异，主要是细节差距，就不具体介绍了：

![%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%2015.png](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%2015.png)

如上图所示，我们希望对 a 进行左旋，首先我们取出 a 的右子树 b ，然后将 b 的右子树 γ 作为 a 的右子树。然后取出 b 节点与 a 的左子树树根两者之间 Y-coordinate 较大的节点 c ，将 c 作为 a 的左子树 α 的根节点， 其中较小的作为 α 的根节点，然后将把 α 作为 b 的左子树，原来 b 的左子树 β 作为b的右子树，最后将 b 作为 a 的左子树。这样就完成了树的左旋。

![%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%2016.png](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%2016.png)

注意我们的旋转是针对与树的非叶子节点的维护，实际上叶子节点作为我们存储数据的结构，不参与我们对树的维护。

## 优先搜索树PST在Linux内核中的应用

[页缓存&内存组织方式](%E9%A1%B5%E7%BC%93%E5%AD%98&%E5%86%85%E5%AD%98%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%20351ab7a6eb64447a9ed2b9178098c8ae.md) 

**Linux 内核中使用的 PST 优先搜索树是最大堆和基数树（请看：[基数树](%E5%9F%BA%E6%95%B0%E6%A0%91%20a0f1ef24ed374d5194803512b15569de.md) ）的混合体**，它的基础是 Edward M. McCreight 于 1985 年发表于计算杂志上的基数优先搜索树 (RPST) 算法。

RPST树可以实现区间的检索，它的每个节点代表一个区间，以**区间的起始值作为基索引， 以区间的终止值作为堆索引，根据基索引可以确定寻找节点的路径，而父子节点的堆索引之间的关系又符合堆的性质**。Linux 的 PST 树去掉了 RPST 树中复杂的对称化处理，并且树的节点和线性区结构**vm_area_struct** 相关联，**使用这种树可以用较低的代价搜索到与指定的页结构有映射关系的线性区集合， 内核正是用它实现了页的反向映射功能。 树节点使用了 3 个索引， 以线性区映射文件的起始页索引、 终止页索引、页面数分别作为基索引 r_index、 堆索引 h_index 和 size (大小)索引**， 每个树节点可以表示为`[r_index， size_index， h_index]`。针对线性区基索引相同的很多，因此树节点有溢出的情况 ，PST 树使用溢出子树对其进行处理。使用 PST 树具有较好的搜索性能，其算法复杂度约为 O (lgH+m)，即 O(树的高度的对数+目标节点数)

![%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%2017.png](%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91%20PST%2091c1d4655c3c454896e4647f8267ea97/Untitled%2017.png)

- 每个节点的堆索引不小于子节点的堆索引。
- 当子节点的堆索引等于父节点的堆索引时， 其基索引小于父节点基索引 (不可能等于， 基索引、 堆索引都相等的节点被置于父节点的线性链表中， 不再作为子节点单独出现)。
- 除根节点外各节点按基索引和基数树性质确定在树中的位置。
- 当出现很多相同基索引而堆索引不同的节点时， 树可能会溢出 (当前高度无法容纳， 而又不能扩充高度)， PST 使用了溢出子树， 这里姑且把原来的树称作主树。 把和叶节点相同基索引的节放入溢出子树， 溢出子树是一棵以主树的叶结点为根的基数树， 它使用了节点区间大小 size 作为基索引。 所以主树使用基索引， 堆索引， 溢出子树使用 size 索引， 堆索引。

### Linux 内核使用PST树的场景

**为了在回收文件页框时找到所有映射该页的进程页表项，Linux2.6 内核使用了文件页的反向映射机制**。 在文件 inode 节点的**地址空间结构 address_space** 中建立了 PST 优先搜索树。树中每个节点表示一个映射到该文件的线性区。通过 PST 树，可以实现**页描述符→线性区→页表项**的反向映射的功能。树节点 由 raw_prio_tree_node 结构表示，而 raw_prio_tree_node 结构由线性区 vm_area_struct 结构包含， 因此根据节点指针就能得到关联的线性区指针， 通过 PST 树， 系统可以查到与指定页page 有重叠的所有 vma， 然后通过以下代码得到文件页 page映射到进程用户空间的线性地址address：

```jsx
pgoff_t pgoff = page ->index << (PAGE_CACHE_SHIFT - PAGE_SHIFT);//page 的页索引
unsigned long address;
address = vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);//page 在 vma 中的线性地址
```

有了用户空间的线性地址， 再加上 vma->vm_mm->pgd 指示的页目录表地址， 要找到对应的页表项就很简单了， 这就是Linux 文件页反向映射的原理。 而其中最关键的一步就是根据指定的页索引快速的遍历到包含该页的所有 vma。 使 用 宏 vma_prio_tree_foreach 可以遍历和所有指定页索引区间有映射的线性区， 定义如下：

```jsx
#define vma_prio_tree_foreach(vma, iter, root, begin, end) \
for (prio_tree_iter_init(iter, root, begin, end), vma = NULL; \
(vma = vma_prio_tree_next(vma, iter)); )
```

这是一个使用游标 iter 遍历 PST 树的循环， 每次循环调用vma_prio_tree_next 函数查找下一个与指定页索引区间 [begin,end] 重叠的 vm_area_struct 结构指针并保存在 vma 中。 当内核回收文件映射页 page 时 ， 调 用 try_to_unmap_file ( struct page*page) 撤销所有的进程映射， 其主体代码是

```jsx
vma_prio_tree_foreach (vma, &iter, &mapping ->i_mmap,pgoff, pgoff) {
	 ret = try_to_unmap_one(page, vma);
}
```

对于找到的每个 vma， 该函数都调用 try_to_unmap_one 函数撤销 vma 线性区中映射到 page 页的页表项