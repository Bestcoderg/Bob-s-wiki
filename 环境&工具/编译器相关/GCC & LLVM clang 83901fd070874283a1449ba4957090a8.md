# GCC & LLVM/clang

在了解 LLVM 和 Clang 之前，先得了解一下什么是编译器。传统的编译器通常分为三个部分，**前端（frontEnd），优化器（Optimizer）和后端(backEnd)。在编译过程中，前端主要负责词法和语法分析，将源代码转化为抽象语法树；优化器则是在前端的基础上，对得到的中间代码进行优化，使代码更加高效；后端则是将已经优化的中间代码转化为针对各自平台的机器代码。**

![GCC%20&%20LLVM%20clang%2083901fd070874283a1449ba4957090a8/Untitled.png](GCC%20&%20LLVM%20clang%2083901fd070874283a1449ba4957090a8/Untitled.png)

如果粗略的分，优化器也算是编译器后端的一部分，主要以中间代码作为两者的分界线。

![GCC%20&%20LLVM%20clang%2083901fd070874283a1449ba4957090a8/Untitled%201.png](GCC%20&%20LLVM%20clang%2083901fd070874283a1449ba4957090a8/Untitled%201.png)

- **GCC**

GCC（GNU Compiler Collection）是一套有 GNU 开发的编程语言编译器，以 GPL 及 LGPL 许可证所发行的自由软件。GCC 原名为 GNU C 语言编译器，它原本只能处理 C 语言，随着技术的发展，GCC 很快地得到扩展，变得可以处理 C++，之后可以处理的语言扩展到 Fortran、Pascal、Objective-C、Java 等。

- **LLVM**

LLVM （Low Level Virtual Machine，底层虚拟机)）提供了与编译器相关的支持，能够进行程序语言的编译期优化、链接优化、在线编译优化、代码生成。从宏观上来讲，LLVM 不仅仅是一个编译器或者虚拟机，**它是一个众多编译器工具及低级工具技术的统称，它包含了一个前端、优化器、后端以及众多的函数库和模板**。**从微观上来讲，可以把它看做后端编译器，用来生成目标代码，前端编译器为 Clang。**

CLang 是一个由 **C++ 编写的编译器前端**，能够编译 C/C++/Objective 等高级语言，属于 LLVM 的一部分，发布于 BSD（自由软件中使用最广发的许可证之一）许可证下，其目的就是为了超越 GCC。经过测试证明，Clang 编译 Objective-C 代码的速度为 GCC 的 3 倍左右，同时它还能针对用户发生的编译错误准确地给出建议。

## **再探 LLVM**

回顾 GCC 的历史，虽然它取得了巨大的成功，但开发 GCC 的初衷是提供一款免费的开源编译器，仅此而已。可后来随着 GCC 支持了越来越多的语言，GCC 架构的问题也逐渐暴露出来。**但 GCC 到底有什么问题呢？**

LLVM 的优点也正是 GCC 的缺点。**传统编译器工作的时候前端负责解析源代码，检查语法错误，并将其翻译为抽象的语法树（Abstract Syntax Tree）。优化器对这一中间代码进行优化，试图使代码更高效。后端则负责将优化器优化后的中间代码转换为目标机器的代码，这一过程后端会最大化的利用目标机器的特殊指令，以提高代码的性能。**事实上，**不光静态语言如此，动态语言也符合上面这个模型，例如 Java。JVM 也利用上面这个模型，将 Java 代码翻译为Java bytecode**。这一模型的好处是，当我们要支持多种语言时，只需要添加多个前端就可以了。当需要支持多种目标机器时，只需要添加多个后端就可以了。对于中间的优化器，我们可以使用通用的中间代码。**这种三段式的结构还有一个好处，开发前端的人只需要知道如何将源代码转换为优化器能够理解的中间代码就可以了，他不需要知道优化器的工作原理，也不需要了解目标机器的知识**。这大大降低了编译器的开发难度，使更多的开发人员可以参与进来。

虽然这种三段式的编译器有很多优点，并且被写到了教科书上，但是在实际中这一结构却从来没有被完美实现过。做的比较好的应该属 Java 和 .NET 虚拟机。虚拟机可以将目标语言翻译为 bytecode，所以理论上讲我们可以将任何语言翻译为 bytecode，然后输入虚拟机中运行。**但是这一动态语言的模型并不太适合 C 语言，所以硬将 C 语言翻译为 bytecode 并实现垃圾回收机制的效率是非常低的。GCC 也将三段式做的比较好，并且实现了很多前端，支持了很多语言。但是上述这些编译器的致命缺陷是，他们是一个完整的可执行文件**，没有给其它语言的开发者提供代码重用的接口。即使 GCC 是开源的，但是源代码重用的难度也比较大。

LLVM 最初的定位是比较底层的虚拟机。它的出现正是为了解决编译器代码重用的问题，LLVM 一上来就站在比较高的角度，制定了 **LLVM IR** 这一中间代码表示语言。LLVM IR 充分考虑了各种应用场景，例如在 IDE 中调用 LLVM 进行实时的代码语法检查，对静态语言、动态语言的编译、优化等。从上面这个图中我们发现 LLVM 与 GCC 在三段式架构上并没有本质区别。**LLVM 与其它编译器最大的差别是，它不仅仅是 Compiler Collection，也是Libraries Collection**。举个例子，假如说我要写一个 X 语言的优化器，我自己实现了 PassX算法，用以处理 X 语言与其它语言差别最大的地方。而 LLVM 优化器提供的 PassA 和 PassB算法则提供了 X 语言与其它语言共性的优化算法。那么我可以选择 X 优化器在链接的时候把LLVM 提供的算法链接进来。**LLVM 不仅仅是编译器，也是一个 SDK**。

Apple LLVM compiler 4.2 是一个真正的 LLVM 编译器，前端使用的是 Clang，基于最新的 LLVM 3.2 编译的。LLVM GCC 4.2 编译器的核心仍然是 LLVM，但是前端使用的是 GCC 4.2 编译器。从 LLVM的下载页面可以看出，LLVM 从 1.0 到 2.5 使用的都是 GCC 作为前端，直到 2.6 开始才提供了 Clang 前端。

如果你下载 LLVM 的代码，**那么它就是一个 IR 到 ARM/机器码的编译器。比如 bin/opt 就是对 IR 的优化器，bin/llc 就是 IR->ASM 的翻译，bin/llvm-mc 就是汇编器。**如果你再从[http://llvm.org](https://link.zhihu.com/?target=http%3A//llvm.org) 下载 Clang，那么就有了 C->IR 的翻译以及完整的编译器 Driver。GDB 是GNU 的调试器。只要编译器支持 DWARF 格式，就可以用 GDB 调试。