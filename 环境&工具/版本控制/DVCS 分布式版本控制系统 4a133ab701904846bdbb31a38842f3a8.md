# DVCS 分布式版本控制系统

DVCS(Distributed Version Control System)，**分布式版本控制系统**，软件开发过程中，要解决多人协作的问题，需要有一个版本控制系统，用来合并和管理多人对同一个项目的开发和修改。版**本控制有两种方式，一种是集中式版本控制系统，**顾名思义，是把代码的管理和同步放在同一个服务器端来进行，如**CVS,SVN**，由于有完善的权限系统，以及统一的服务端，适合商业软件的开发；而另一种**分布式版本控制系统**，主要有Git和Mercurial，则相当于把集中式版本控制系统的服务端和客户端都交给参与开发的客户端来保管，只有需要不同开发者合并代码时，才需要一个中转站来完成。在这片文章我们主要讨论git和Mercurial的区别。

### 快照机制与分支管理

Mercurial通过changesets存储文件的改动，这种做法被称作基于差异（delta-based）的版本控制。Mercurial只是保存每个版本之间的变化，**这种做法显然的好处是大部分情况下占用空间较小，同时很容易比较两个版本之间的差异**。另外，在工作中经常需要看某行代码的改动是哪个changeset中进行的（如使用hg blame），Mercurial在查看此类信息时效率很高。但其进行分支切换时总是需要从头开始进行完全的迭代操作，这是非常慢的。

Git使用完全不同的方法存储文件改动：通过存储文件快照（snapshot）来保存文件状态。git会读取当前工作空间的所有数据，进行数据预存，再重新调整。它会和上一次的快照版本的内容进行比较，对于没有改变的文件数据，**git会把当前预存中冗余文件的数据去除掉**，**改为保留指向上一个版本中该文件数据的指针，对于有差异的文件数据就会保留下来，最终再把数据完整保存下来，**这才算是执行了一次快照。Git的优势是快，天下武功唯快不破，所以Git最终能一统江湖，千秋万代。虽然Git的速度很快，但是随着版本的增多或者对于文件特别大的项目，Git会有点吃力。毕竟，存储了过多的文件快照，如同吸星大法一样，会有反噬作用。由于库的大小在迭代过程中不断膨胀，git除了rebase机制，整合分支，这是一种缩减库大小的好方法，但实际上是有一些违背git精神的，所以总是备受诟病。

### 暂存区

学习Git时首先感受到的不同是暂存区（Staging Area）的存在。为什么要增加这么个步骤？这样做显然在commit的时候要多一步git stage。虽然git commit -a可以做到两步合一，但是多这么一步，设计者一定有他的用意。

首先，从通用层面说，这样做可以提醒自己什么改动预备commit，什么不是。如果一个改动我打算在新一版中commit，那么我需要手动将其stage到暂存区。这可以看作是一种软件帮助完善work flow的行为。之前在工作中，有时会临时用sed替换环境文件中开关选项，这些改动并不需要被commit记录。使用Mercurial话，默认做法会导致你有可能误push这样的改动，而Git的暂存区需要你有意识的stage需要commit的文件。所以除非你非常确定自己在做什么，否则不应该无脑使用git commit -a。

其次，暂存区可以当作一种保存阶段性工作的方式。当对文件的改动还不足以达到一次commit的粒度，但又算是阶段性成果时；或者改动尚未验证正确性时，暂存区可以充当一种缓存的存在。在暂存之后，我尽可以继续完善之前的修改，又或者尝试一个临时的想法。因为暂存区的存在，我可以非常方便的把暂存区的版本与工作目录下的版本进行比较，把它们两者与改动前版本进行对比；或者对暂存区和工作目录文件独立的使用撤销操作，也可以吧暂存区的快照恢复到工作目录。如果使用Mercurial，恐怕要么我需要commit一个中间版本，要么通过cp文件的方式保存多个版本的改动。有了暂存区，尝试临时的想法也变成了一个轻量级的操作。