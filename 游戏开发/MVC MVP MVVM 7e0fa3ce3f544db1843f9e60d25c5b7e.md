# MVC MVP MVVM

> *以下的文章集合于博客，但个人依旧觉得下面这篇知乎，值得一看。在方法论的方面讲的不错[https://www.zhihu.com/question/20148405](https://www.zhihu.com/question/20148405)*
> 

## 历史周期率

那么我们就按照大致的历史进程将这些概念进行划分：

- Script
- Code Blocks、Code Behind
- MVC、MVP、MVVM

我们知道的是现实的历史发生顺序并不如上，因为思想都是相似的，比如MVC很早很早就出现了，解释型语言至今基本上也有很多分支而且在互联网时代大行其道。

- **Script时代：**
最早的Script时代，这里脚本的意思不是指当时是用脚本开发，而是像写脚本一样开发。它们都有一个特点：功能单一、管理单一、入口单一。工作内容多是编写的机器控制指令，有些甚至是命令，比如至今依然保留的Command。在Script时代讲UI等于放屁，根本不存在这种概念。但全赖我们有神器——**摩尔定律**。

但我个人认为摩尔定律是不足以让一个敲命令行的时代在几十年间转变成这种各类框架技术架构实践模式的时代，真正推动计算机形成自有的工程学体系的是还有两样东西就是：

- **人的能力并没有变强**，至少没有在同级数下变强。
- **人类一定会物尽其用**

因为人的能力并没有“跟上”机器，所以才会出现各种模式、方法、工具等等来补足人的不足，以最大地透支机器性能。就像我前几天在闪存无聊时突然想到的一句： **架构是对客观不足的妥协，规范是对主观不足的妥协**。

当我们需要机器做的事情多了起来，我们就没办法在一个芯片上解决所有事情，所以才会有冯诺依曼模型、计算机架构，没办法用一台机器解决，所以才要互联网、分布式、云计算。

同样，随着计算机的发展，**要做的事情多了，就出现了软件的概念**。当“开发”正式化，我们需求的软件就变得：**功能繁杂、管理统一、多入口**。

**真正变化的不是客观本质，而是需求**。就像这里说的“软件入口”在客观上我们还是只有一个，原理上始终都只有一个启动程序、一个启动代码片段。但**“软件的入口”，已经从指代Main函数变成了指代起始UI，用户已经从指代专业人士变成了指代一般消费者，先有软件的需求，才有软件的定义，而需求是在变化的**。

一个软件需要比当时多几个数量级的代码：

- 客观上我们没办法做一个能显示所有代码的显示器
- 主观上我们没办法在超快速滚动中看清所有代码

**所以我们需要添加索引、用多个文件组织代码**。

机器的发展和软件的需求扩大和细化，我们开始出现了用户界面（User Interface）的概念和最适合用于界面的语言——标记语言（Markup Language）。当然，ML不是为UI而生的，它只是十分适合UI，所以才和UI坠入爱河。

**因为有了更高UI的需求，所以代码才正式被分化为描述做什么（业务逻辑）和有什么（UI）的两部分，因为我们开发时没办法在两种思维方式下同时工作，开发时的人脑是单线程的**。我们所看到的同时进行UI和逻辑开发只不过是我们学会了在两种模式下快速切换，看起来像同时进行，而不是真正的同时进行。同样的情况也发生在不同的代码片段的开发中。

分化的情况除了UI，还发生在方方面面，比如数据操作、UI的对象和样式分离。

**当需求变得庞大，解决方案也会变得庞大；当解决方案变得庞大，就会出现细分；当出现细分，就会出现按哪种方式管理的问题**。

**软件从处理一件事务发展到了要处理许多事务**，各事务间有包含、顺序、主次等等的关系，变得越来越复杂。因为数据与逻辑庞大了，所以数据与逻辑就分离了，然后事件和业务分离了。

**它们的关系已经在我们还理得清之前持续发展而变得更加难理得清**，但在一个时间点上，它们UI的领域大致分化成这些原子：

- 界面
- 数据
- 事件
- 业务

你要细化的话会有更多繁杂的细节，但相信这么写的话争议性比较小。

**当一个问题出现一次的时候它是一个问题，当一个问题出现了无数次的时候它会成为历史，当一个问题将会出现无数次的时候，它将需要一个明确的定义和解决方案。**

其中，**数据的更新和界面的更新这一特殊事件的问题被放大了无数倍，因为它出现了无数次**。

## MVX

![Untitled](MVC%20MVP%20MVVM%207e0fa3ce3f544db1843f9e60d25c5b7e/Untitled.png)

MVC、MVP和MVVM是三种流行的设计模式。其中，MVC表示模型-视图-控制器，MVP表示模型-视图-演示者，MVVM表示模型-视图-视图模型；MVP, MVVM都是由MVC衍生出。所有这些设计模式大体上都有助于开发松散组合、易于测试和维护的应用程序。

MVC表示“模型-视图-控制器”，MVP表示“模型-视图-演示者”，MVVM表示“模型-视图-视图模型”；MVP、MVVM都是由MVC衍生出的。MVC中，View会直接从Model中读取数据；MVP中，View并不直接使用Model。

### 一、MVC（Model-View-Controller）

MVC是比较直观的架构模式，最初生根于服务器端的Web开发，后来渐渐能够胜任客户端Web开发，能够满足其复杂性和丰富性。

![Untitled](MVC%20MVP%20MVVM%207e0fa3ce3f544db1843f9e60d25c5b7e/Untitled%201.png)

MVC模式将应用程序划分为三个部分：

●　Model: 模型（用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法）

●　View: 视图（渲染页面）

●　Controller: 控制器（M和V之间的连接器，用于控制应用程序的流程，及页面的业务逻辑）

**MVC特点：**

MVC模式的特点在于实现关注点分离，即应用程序中的数据模型与业务和展示逻辑解耦。在客户端web开发中，就是将模型(M-数据、操作数据)、视图(V-显示数据的HTML元素)之间实现代码分离，松散耦合，使之成为一个更容易开发、维护和测试的客户端应用程序。

用户操作->View（负责接收用户的输入操作）->Controller（业务逻辑处理）->Model（数据持久化）->View（将结果反馈给View）：

1、View 传送指令到 Controller ；

2、Controller 完成业务逻辑后，要求 Model 改变状态 ；

3、Model 将新的数据发送到View，用户得到反馈。

![Untitled](MVC%20MVP%20MVVM%207e0fa3ce3f544db1843f9e60d25c5b7e/Untitled%202.png)

View 传送指令到 Controller,Controller 完成业务逻辑后，改变 Model 的状态，Model 将新的数据发送到 View，这就是 MVC 模式的处理逻辑。

### 二、MVP（Model-View-Presenter）

MVP是把MVC中的Controller换成了Presenter（呈现），目的就是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离方向。

![Untitled](MVC%20MVP%20MVVM%207e0fa3ce3f544db1843f9e60d25c5b7e/Untitled%203.png)

![Untitled](MVC%20MVP%20MVVM%207e0fa3ce3f544db1843f9e60d25c5b7e/Untitled%204.png)

MVP特点：

●　M、V、P之间双向通信。

●　**View 与 Model之间不通信，都通过 Presenter 传递**。Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。

●　View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。

●　Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，这样就可以重用。不仅如此，还可以编写测试用的View，模拟用户的各种操作，从而实现对Presenter的测试–从而不需要使用自动化的测试工具。

### 三、MVVM（Model-View-ViewModel）

MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。如果说MVP是对MVC的进一步改进，那么MVVM则是思想的完全变革。它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上。

![Untitled](MVC%20MVP%20MVVM%207e0fa3ce3f544db1843f9e60d25c5b7e/Untitled%205.png)

### 总结：

在MVC中，View会直接从Model中读取数据而不是通过 Controller；View和 Controller之间存在多对一关系。

在MVP中，View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部；View和Presenter之间是一对一关系。

MVVM 模式基本上与 MVP 模式完全一致，唯一的区别是：MVVM采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。

### MVC&MVP的区别

**1.Activity 职责不同**

Activity 在 MVP 中是 View 层，在 MVC 中是 Controller 层，这是 MVC 和 MVP 很主要的一个区别，可以说 Android 从 MVC 转向 MVP 开发也主要是优化 Activity 的代码，避免 Activity 的代码臃肿庞大。

**2.View 层不同**

MVC 的 View 层指的是 XML 布局文件或者是用 Java 自定义的 View，对应的是各种 Layout 布局文件，MVP 的 View 层是 Activity 或者 Fragment。

**3. 控制层不同**

MVC 的控制层是 Activity，或者是 Fragment，Controller 对应的是 Activity，而 Activity 中却又具有操作 UI 的功能，我们在实际的项目中也会有很多 UI 操作在这一层，也做了很多 View 中应该做的事情，当然 Controller 层 Activity 中也包含 Controller 应该做的事情，比如**各种事件的派发回调，而且在一层中我们会根据事件再去调用 Model 层操作数据**，所以这种 MVC 的方式在实际项目中，Activity 所在的 Controller 是非常重的，各层次之间的耦合情况也比较严重，不方便单元测试。MVP 的控制层是 Presenter，里面没有很多的实际东西，主要是做 Model 和 View 层的交互。

**4. 关系链不同**

MVP 中 Model 层与 View 是没有关系的，彼此不会通讯和操作，Model 与 View 的通讯都是 Presenter 层来传达的。但是在 MVC 中，Model 层和 View 是曾在交互的。比如我们自定义的 View 控件里面肯定是要使用 Model 的数据的，View 也要根据不同的 Model 数据做出不同的展现！这点尤其是体现在自定义的 View 中，自定义 View 需要设置数据，用户操作了自定义控件需要改变数据，View 要操作 Model 怎么办？有人说把 Controller 传到自定义的 View 啊，现实是不可能没一个自定义 View 都去持有 Controller 的引用，其实在 MVP 中就不会这么尴尬，接口就可以完成。

**5. 适用范围不同**

在 Android 中，MVP 和 MVC 都用自己的适用情况，使用 MVP 可以更好的解耦三大模块，模块之间比较清晰，也很方便使用 MVP 来组件化架构整体项目。但是 MVC 也是有用武之地的，在组件化的 Module 或者中间件我们可以使用 MVC 来做，Module 或者中间件不会存在很复杂的 View 层，使用 MVC 可以更加方便我们实现功能。

**6. 交互方式不同**

MVP 中通讯交互基本都是通过接口的，MVC 中的通讯交互很多时候都是实打实的调用对象的方法，简单粗暴！

**7. 实现方法不同**

MVC 和 MVP 的 Model 几乎一样的，都是处理数据，只要不在 Activity 或者 Fragment 中请求数据，其他的所有控制都放在 Activity 或者 Fragment 中，这样写就基本是 MVC 的模式，这样写不麻烦，但是很容易把 Activity 写出上万行代码。用 MVP 的时候我们需要写很多 View 和 Presenter 接口来实现模块之间的通讯，会增加很多类。