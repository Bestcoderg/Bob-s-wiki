# CLR 公共语言运行时

什么是公共语言运行时（Common Language Runtime, CLR）？(请看[.Net & Mono & IL2CPP](Net%20&%20Mono%20&%20IL2CPP%200c7c774e2cec4692852a9825bba00340.md) )

> 公共语言运行时（CLR）是一套完整的、高级的虚拟机，它被设计为用来支持不同的编程语言，并支持它们之间的互操作。
> 

[什么是 CLR ？](https://zhuanlan.zhihu.com/p/68158037)

## CLR：一个完备的编程平台

每一个程序都有大量的运行时依赖。当然，一个程序需要由某种特定的编程语言编写而成，不过这只是程序员把想法变成现实的第一步。所有有意义的程序，都免不了需要与一些运行时库 打交道，以便能够操作机器的其他资源（比如用户输入、磁盘文件、网络通讯，等等）。程序代码还需要某种变换（翻译或编译）才能够被硬件直接执行。这些依赖实在是太多了，不仅种类繁多还互相纠缠，因此编程语言的实现者通常都把这些问题交由其他标准来指定，即由操作系统来提供当前平台的接口。例如，C++ 语言并没有制定一种 “C++可执行程序” 格式；相反，每个 C++ 编译器都会与特定的硬件架构（例如 x86）以及特定的操作系统（例如 Windows、Linux 或 macOS）绑定，它们会对可执行文件的格式进行描述，并规定要如何加载这些程序。因此，程序员们并不会搞出一个 “C++可执行文件”，而是 “Windows X86 可执行程序” 或 “Power PC Mac OS 可执行程序”。

通常来说，直接使用现有的硬件和操作系统标准是件好事，但它同样也会把语言规范与现有标准的抽象层次紧密捆绑起来(实际上我们在C++项目种常会看到如 #ifdef WINDOWS 这类的宏，在语言层面，这导致了用户考虑了”过多“的东西)。同时，如果语言与操作系统紧密捆绑，将导致我们许多功能难以实现，例如，常见的操作系统并没有支持垃圾回收的堆内存，因此我们就无法用现有的标准来描述一种能够利用垃圾回收优势的接口。除此之外，一个可执行程序运行时还需要大量的运行时库，为每个程序都考虑环境问题是非常痛苦的一件事情。

CLR 能够解决这些问题，因为它制定了一套非常完整的规范（已被 ECMA 标准化）。这套规范描述了一个程序的**完整**生命周期中所需要的所有细节，从构建、绑定一直到部署和执行。例如，CLR 制订了：

- 一个支持 GC 的虚拟机，它拥有自己的指令集（叫做公共中间语言，Common Intermediate Langauge），用来描述程序所能执行的基本操作。这意味着 CLR 并不依赖于某种特定类型的 CPU。
- 一种丰富的**元数据**表示，用来描述一个程序的声明（例如类型、字段、方法等等）。因此编译器能够利用这些信息来生成其他程序，它们能够从“外面”调用这段程序提供的功能。
- 一种文件格式，它指定了文件中各个字节所表达的意含义。因此你可以说，一个 “CLR EXE”并没有与某个特定的操作系统或计算机硬件相捆绑。
- 已加载程序的生命周期语义，即一种 “CLR EXE 引用其他 CLR EXE” 的机制。同时还制订了一些规则，指定了运行时要如何在执行阶段查找并引用其他文件。
- 一套类库，它们能够利用 CLR 所支持的功能（例如垃圾回收、异常以及泛型）来向程序提供一些基本功能（例如整型、字符串、数组、列表和字典），同时也提供了一些与操作系统有关的功能（例如文件、网络、用户交互）。
    
    ![C#%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%20cc2ec1f8c00c4790bcaaf0d466312015/Untitled.png](C#%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%20cc2ec1f8c00c4790bcaaf0d466312015/Untitled.png)
    

### 对于多语言的支持

定义、规范以及实现所有这些细节是一项艰巨的任务，这也是为什么像 CLR 一样完备的抽象非常少见。事实上，大部分这些基本完备的抽象都是为某一个语言而生的。例如，Java 运行时、Perl 翻译器、或是早期的 Visual Basic 运行时，都提供了类似的完整的抽象界限。使得 CLR 在这些工作中脱颖而出的是它的多语言支持特性。很多语言，当单独使用时，体验很好；但当与**其他语言交互时**却非常麻烦。语言之间的交互难点在于，它们只能使用操作系统所提供的基本功能与其他语言进行交互。由于**操作系统的抽象层次太低**（例如操作系统并不知道支持垃圾回收的堆内存是什么），因此跨语言交互通常都很复杂。通过提供公共语言运行时，CLR 允许语言之间使用更高层次的结构进行交互（例如支持 GC 的结构），极大简化了交互的复杂性。

由于运行时在 很多 语言之间共享，它意味着我们我们可以投入更多的资源在运行时上。为一个语言构建一个优秀的调试器和性能分析器通常需要大量的工作，因此通常来说只有那些最重要的编程语言才拥有完备的调试器和性能分析器。然而，由于在 CLR 上的语言可以复用这些基础设施，为某种语言实现调试器的负担就会减轻很多。更重要的时，任何建立在 CLR 之上的语言，都可以立刻获得访问 所有 类库的能力。这些庞大（并且还在不断完善）的类库是 CLR 成功的另一个重要原因。

简而言之，运行时就是一套完整的规范，它规定了创建和运行一个程序所需要的方方面面。而负责运行这些程序的虚拟机，非常适合用来实现各种各样的编程语言。这个虚拟机、以及跑在这个虚拟机上的（不断完善的）类库，就是我们所说的公共语言运行时（CLR）。

## CLR 的主要目标

现在我们对 CLR 是什么有了一个基本的认识，下面我们就来看看运行时究竟想要解决什么问题。从非常高的角度来说，运行时只有一个目标：

> **CLR 的目标是让编程变得简单。**
> 

这条表述可以从两方面来理解：

一方面，在运行时不断进化的过程中，这是一条 非常 有用的指导准则。例如，从根本上来说，简洁的东西才会简单。如果某个改动会向运行时中添加**用户可见的复杂性**，我们就需要秉持怀疑的态度来审视。相比于计算某个功能的“**成本收益比**”，我们更看重“添加的用户可见复杂度“ 与 ”在所有场景上的加权收益” 之比。理想情况下，这个比值应该是负的——即新功能通过减少限制或泛化特例，从而使的复杂性降低。在现实情况下，我们应当尽量最小化暴露给外部的复杂度，并最大化这个功能所适用的场景。

另一方面，这个目标的重要性在于：**易用性是 CLR 成功的基石。**CLR 并不是因为比原生代码更快更小而成功的（事实上，写的好的原生代码通常在这些方面都会胜出）；CLR 也并不是因为提供了某种特别的功能而成功的（例如垃圾回收、平台无关、面向对象编程或版本管理）。CLR 的成功在于：这些功能、以及其他不计其数的功能加在一起，使得编程变得简单得多。很多很重要但是经常被忽视的易用功能包括：

1. 简化的语言（例如，C# 和 Virual Basic 要比 C++ 简单太多）
2. 致力于简化类库（例如，我们只有一种字符串类型，它是不可变的；这极大地简化了适用字符串的 API）
3. 类库中名称之间很强的一致性（例如，要求 API 使用完整的单词，并使用一致的命名规范）
4. 对创建一个程序所需要的工具链提供了大力支持（例如，Visual Studio 使得构建 CLR 应用程序非常简单，Intellisense 使得查找正确的类型和方法变得非常容易）

正是这些在易用性上的努力（它们与用户模型的简单性密切相关），才是 CLR 能够成功的原因。奇怪的是，一些在易用性方面**最重要的特性通常都是最“无聊”**的。比如，其实任何编程环境都可以提供一致的命名规范，但在如此庞大的类库上保持一致性还是需要很多工作的。

**CLR 的主要功能：**

运行时有很多功能，我们可以概括为以下几类：

1. **基础功能**——那些对其他的特性有广泛影响的功能。包括：
    1. 垃圾回收
    2. 内存安全和类型安全
    3. 对编程语言的高级支持
2. **次要功能**——那些由基础功能发展而来的、但不是必须的功能：
    1. AppDomains 程序隔离
    2. 程序安全与沙盒
3. **其他功能**——那些运行时环境需要的、但并不依赖基础功能的特性。这些功能帮助我们建立了一个完整的编程环境。比如：
    1. 版本管理
    2. 调试、性能分析
    3. 互操作

## CLR 垃圾回收器GC

为什么要将GC单独拉一章出来谈呢？因为它实在是太太太重要啦，也太太太好用啦！垃圾回收（GC）的意思是“内存自动回收”。在一个支持垃圾回收的系统中，用户程序不再需要调用一个特殊的操作符来删除内存。相反，运行时会自动跟踪在 GC 堆内存上的所有内存引用，并且他会不时地遍历这些引用，判断这些内存是不是还会被程序所使用。所有不再被使用的内存就是 垃圾，它们可以被用于新的内存申请。

垃圾回收是一个非常有用的功能，因为它简化了编程工作。最明显的简化就是，大多数显式的删除操作都可以省略了。当然，省略删除操作这一点很重要，但垃圾回收给程序员带来的真正价值要更微妙一点：

1. 垃圾回收简化了接口设计。没有垃圾回收的话你就需要考虑，究竟接口的哪一侧需要负责删除在接口上传入传出的对象。例如，CLR 的接口就可以很简单地返回一个字符串，我们不需要担心字符串的缓冲区和长度。这也意味着我们也不需要担心“缓冲区是不是足够大”。因此，垃圾允许运行时中所有的接口都要比以前更简洁一些。
2. 垃圾回收消除了一些常见的用户错误。对于某一个特定的对象来说，我们非常容易搞错它的生命周期，要么是删除的太早（将会导致内存内容失效），或者删除的太晚（内存泄漏）。一个典型的程序会使用成千上万个对象，出现错误的概率确实很大。更进一步，生命周期这一类的 bug 很难调试，尤其是这个对象被很多其他对象所引用的时候。垃圾回收使得这类错误不会再发生，给我们带来了很大的便利。

垃圾回收给运行时带来了一个最直接的需求：

> 垃圾回收要求运行时跟踪 GC 堆内存上所有的引用。
> 

当然如果我们需要在程序运行时每时每刻都知道每一个指针指向那个对象，这是非常困难的，但是我们可以降低我们的要求，只有在真正进行垃圾回收的时候知道指针的指向就可以了。但除此之外，由于CLR需要支持并发执行多线程。在任何时间，某个线程的执行都可能会导致内存的申请，进而可能需要进行一次垃圾回收。并发线程的执行顺序是无法确定的，我们没办法知道当一个线程出发了垃圾回收时另一个线程在干什么。因此，GC 有可能发生在某个线程执行当中的任何时间。CLR 并不需要 立即 响应某个线程的 GC 请求，因此 CLR 确实还是有一定的“回旋余地”的。不过，CLR 还是需要保证它能在一定的时间内对 GC 请求做出响应。

## 什么是”托管代码“

这种能够做到“几乎随时”报告所有仍然生效的 GC 引用的代码，就叫做“托管代码”（因为它由 CLR 进行“托管”）。不满足这样的要求的代码就叫做非托管代码。因此所有在 CLR 启动之前执行的代码都是非托管代码，例如，所有的操作系统代码都是非托管的。

### 栈展开问题

很明显，由于托管代码需要使用操作系统提供的服务，有时托管代码就需要调用非托管代码。类似地，由于托管代码是由操作系统所启动的，因此有时非托管代码还会调用托管代码。因此，如果你在任意时刻暂停了某个托管程序，调用栈中将会混合着由托管代码和非托管代码创建的不同类型的栈帧。

但是当非托管代码与托管代码一起运行时，我们很难保证我们之前所提到的一些特性还能实现。因为非托管代码所创建的栈帧只要满足程序能够运行就可以了。比如这些栈帧并不需要支持查看谁调用了它们。这就是说，如果我们暂停了一个程序，它恰好正在执行非托管代码，那么并没有一种通用的方法能够知道调用者是谁。虽然我们能够在调试器中看到调用者，但这是由于有额外的符号信息支持（PDB文件），而这种信息并不保证一定存在（这就是为什么在调试器里我们也经常拿不到完美的 Stack Trace）。对于托管代码来说，这绝对是个问题，因为栈里面很可能包含有托管代码的栈帧（托管代码的栈帧中包含了需要报告的 GC 引用）。

对于这个问题 .net CLR所执行的操作是，当我们从托管代码进入非托管代码的世界时（或者非托管代码调用托管代码也一样），托管代码必须进行额外的操作来绕过非托管代码无法进行栈展开的问题。在实践中，托管代码会把所有包含托管栈帧的内存块都互相连起来。因此，虽然我们还是没办法不借助调试信息来展开非托管栈帧，但是我们能够做到始终能够找到一块托管代码产生的栈内存，然后遍历所有的托管栈帧块。当每次进入、退出托管代码的世界时，就必须执行这种额外的机制。不论进入还是退出，CLR 都一定会知道。

### 托管代码与非托管代码的世界

这两个世界泾渭分明（在任何时刻，代码要么在托管世界，要么在非托管世界）。更进一步，因为托管代码的执行基于一种 CLR 熟知的格式（以及使用公共中间语言， CIL），并且是 CLR 将其转换为能够在硬件上直接执行的指令，因此 CLR 能够做出比只是“执行” 多得多 的操作。比如，CLR 能够改变“从一个对象中读取成员”或“调用一个函数”的意义。事实上，CLR 在创建 MarshalByReference 对象时就是这么做的。它们看起来像是普通的本地对象，但事实上它们可能保存于另一台机器上。简而言之，在CLR 的托管世界中存在大量的 执行钩子，它们可以用来实现非常强大的功能。我们下文会详细介绍。

在非托管的世界，是没有 GC 指针的（因为它们无法被追踪），同时托管代码调用非托管代码还存在着额外的开销。这就意味着，虽然你 可以 调用任意的非托管代码，但这种体验不是很友好。非托管方法的参数和返回值并不包含 GC 对象，也就是说，它们所创建和使用的对象及对象句柄需要显示释放。同时，这些 API 还无法使用 CLR 所支持的功能（例如异常和继承），它们与托管代码在用户体验上并不统一。所以对于这种情况，我们总是将非托管的接口在 包装 之后才提供给托管代码使用。例如，当访问文件的时候，你并不会直接使用操作系统提供的 Win32 CreateFile 函数，而是使用包装了文件操作的 System.IO.File 类。让用户直接使用非托管的功能确实非常少见。这一类的接口 ”整容“ 为我们带来了极大的好处，为什么？因为运行时的终极目标是 **使编程变得简单**，通常来说非托管函数并不足够简单。但当我们对其经过一层包装后，这些接口通常会变得 统一 而 简单。

### 托管执行过程

- 选择编译器：使用一个或多个面向运行时的语言编译器。
- 编译为 MSIL：编译为托管代码时，编译器将源代码转换为 Microsoft 中间语言 (MSIL)，这是一组独立于 CPU 且可以有效地转换为本机代码的说明。 MSIL 包括有关加载、存储、初始化和调用对象方法的说明，以及有关算术和逻辑运算、控制流、直接内存访问、异常处理和其他操作的说明。 代码可以运行之前，必须将 MSIL 转换为特定于 CPU 的代码，通常通过 实时 (JIT) 编译器实现。 由于公共语言运行时为其支持的每个计算机基础结构提供一个或多个 JIT 编译器，同一组的 MSIL 可以在任何受支持的基础结构上进行 JIT 编译和运行。
当编译器生成 MSIL 时，它还生成元数据。 元数据描述代码中的类型，包括每种类型的定义、每种类型的成员的签名、代码引用的成员以及运行时在执行时间使用的其他数据。 MSIL 和元数据包含在一个可移植的可执行 (PE) 文件中，该文件基于且扩展已发布的 Microsoft PE 和历来用于可执行内容的通用对象文件格式 (COFF)。 容纳 MSIL 或本机代码以及元数据的这种文件格式使操作系统能够识别公共语言运行时映像。 文件中元数据的存在以及 MSIL 使代码能够描述自身，这意味着将不需要类型库或接口定义语言 (IDL)。 运行时在执行期间会根据需要从文件中查找并提取元数据
- 将 MSIL 编译为本机代码：在加载和执行程序集的内容时，JIT 编译在应用程序运行时按需将 MSIL 转换为本机代码。 由于公共语言运行时为每个受支持的 CPU 基础结构提供 JIT 编译器，开发人员可以构建一组 MSIL 程序集，这些程序集可以进行 JIT 编译并可在具有不同计算机基础结构的不同计算机上运行。 但是，如果你的托管代码调用特定于平台的本机 API 或特定于平台的类库，它将仅在该操作系统上运行。
- 运行代码： 公共语言运行时提供启用要发生的托管执行的基础结构以及执行期间可使用的服务。 方法可以运行之前，必须编译为特定于处理器的代码。 当第一次调用，然后运行时，为其生成 MSIL 的每种方法都是 JIT 编译的。 下次运行该方法时，将运行现有的 JIT 编译的本机代码。 重复 JIT 编译，然后运行代码的过程，直到执行完毕。

## 内存安全

由垃圾收集器带来的一个不那么明显、但影响深远的特性是：内存安全。内存安全性要求不会有任何“野指针”（悬空指针）指向某个随机的内存地址（更准确地说，不会指向提前释放了的内存）。很显然，我们希望所有程序都能够做到内存安全。悬空指针就是程序 bug，调试这种 bug 通常有一些难度。

> GC 是提供内存安全保证的必要条件
> 

显然，GC消除了用户提前释放内存的可能性（从而不会访问到没有正确申请的内存）。在没有GC的程序中对象的生命周期基本上处于随意管理的状态（不像栈内存、或静态申请的内存，它们需要遵守高度受限的申请协议）。在这样的不受限的环境下，静态程序分析器无法确定需要在哪里插入显式的释放语句。实际上，决定何时释放内存的唯一途径就是在运行时确定。这其实就是 GC 的任务（检查某块内存是否仍然有效）

GC 是保证内存安全的必要条件，但不充分。GC 并不会禁止程序越界访问数组，或是越界访问一个对象的成员（如果你通过基地址和偏移来计算成员地址的话）。不过，如果我们有办法解决这些问题，我们就能够实现内存安全的程序。

公共中间语言（CIL）确实 提供了一些操作符，它们可以用来在任意内存上读取和写入数据（因此破坏了内存安全性），不过他还提供了下面这些内存安全的操作符，CLR 也强烈建议在大多数的情况下使用它们：

1. 字段访问操作符（LDFLD、STFLD、LDFLDA），它们能够通过名字来读取、写入一个字段，以及获取一个字段的地址。
2. 数组访问操作符（LDELEM、STELEM、LDELEMA），它们能够通过数据索引来读取、设置数组元素，以及获取数组元素的地址。所有的数组都有一个标签，写明了数组的长度。在每次访问数组元素时，都会自动进行边界检查。

使用这些操作符来取代那些低级的（同时也是不安全的）内存访问操作符，同时避免使用其他的不安全的 CIL 操作符（例如有一些操作符支持跳转到任意地址），这样的话我们就可以创建一个内存安全的系统了。但是，仅此而已。CLR 没有选择这条路；相反，CLR 选择了确保一个更强的不变量：类型安全。

对于类型安全来说，从概念上讲，每一块申请的内存都将与一种类型相关联。所有在内存地址上的操作都将在概念上使用有效的类型进行标记。类型安全需要保证的是，某一块标记了某一种特定类型的内存，只能够进行这种类型允许的操作。这不仅确保了内存安全（没有悬空指针），同时它还对不同的类型提供了额外的保证。

在这些与类型相关的保证当中，最重要的保证之一就是（与字段相关联的）可见性控制属性（Attribute）。如果一个字段声明为 private（仅能够由这个类型中的方法所访问），那么这种限制就会被所有其他的类型安全的代码所遵守。例如，某个类型可能会声明一个名为 count 的字段，它代表了一张表里面对象的个数。假设这个 count 和这张表都是 private 的，同时我们假定代码一定会同时把这两个成员一起更新，那么现在我们就有了一个强保证：在所有类型安全的代码中，count 和这张表中的对象个数是一致的。当我们编写程序时， 不论程序员知道与否，他们无时无刻都在利用着类型安全的概念。CLR 将类型安全由编程语言/编译器之间的简单约定，提升到可以在运行时也严格执行的强制约定。

从概念上说，为了保证类型安全，我们需要对程序的每一个操作进行检查，以便确保目标内存的类型是否与这种操作兼容。尽管我们可以做到这一点，但可想而知肯定非常慢。在 CLR 中，我们有 “CIL 验证”的概念，在代码运行之前，**我们会对 CIL 进行一次静态分析，进而确保大多数操作都是类型安全的**。只有当这种静态分析无法满足需求时，运行时检查才有必要。在实践当中，**需要运行时检查的情况其实并不多见，其中包括**：

1. 将一个指向基类的指针转换为指向子类的指针（相反的操作可以进行静态检查）
2. 数组边界检查
3. 将指针数组中的一个元素赋值为一个新的（指针）值。需要这种检查的原因是，CLR 的数组支持自由转换规则（后文会详细介绍）

需要注意的是，运行时需要额外的特性来满足这些检查的需要：

1. 所有在 GC 堆上的内存必须标记其类型（以便转换操作能够执行）。它的类型信息在运行时必须能够获得，而且必须包含足够的信息来确定类型转换是否合法（例如，运行时需要知道继承结构）。事实上，GC 堆中的每一个对象的第一个字段都指向一个表示其类型的数据结构。
2. 所有的数组必须包含它的大小（以便进行边界检查）
3. 数组必须包含它的元素类型的完整类型信息

幸运的是，大多数看起来昂贵的要求（例如为每一个堆对象标记类型）已经是为了实现垃圾回收所必须的条件了（例如 GC 需要知道每个对象中需要扫描的字段），因此类型安全所带来的额外开销并没有多少。

### 异常

另一个 CLR 直接支持的高级语言结构是异常。异常允许程序员在发生错误时 抛出 一个任意的对象。当这个对象被抛出时，运行时就会搜索调用栈，去寻找是否有哪个方法声明了它可以 捕捉 这个异常。如果这样的捕捉声明存在，程序就继续从捕捉声明这里执行。异常的用途在于它规避了程序员忘记检查某个方法是否成功。异常有助于程序员规避错误（因而使得编程变得简单），因此 CLR 支持它们也就不奇怪了。

尽管异常能够避免这类常见错误，但它们无法解决另一类问题：在异常发生时，如何将数据恢复至一致的状态。这就是说，在异常被捕获之后，很难讲如果继续执行的话会不会发生（由第一次的错误而引起的）其他的错误。这一方面是 CLR 在未来值得拓展的地方。不过就目前来说，异常仍然是向前迈出的一大步（我们还需要走得更远）。

## 元数据

元数据是一种二进制信息，用以对存储在公共语言运行时可迁移可执行文件 (PE) 文件或存储在内存中的程序进行描述。 将您的代码编译为 PE 文件时，便会将元数据插入到该文件的一部分中，而将代码转换为 Microsoft 中间语言 (MSIL) 并将其插入到该文件的另一部分中。 在模块或程序集中定义和引用的每个类型和成员都将在元数据中进行说明。 当执行代码时，运行时将元数据加载到内存中，并引用它来发现有关代码的类、成员、继承等信息。

元数据以非特定语言的方式描述在代码中定义的每一类型和成员。 元数据存储以下信息：

- 程序集的说明。
    - 标识（名称、版本、区域性、公钥）。
    - 导出的类型。
    - 该程序集所依赖的其他程序集。
    - 运行所需的安全权限。
- 类型的说明。
    - 名称、可见性、基类和实现的接口。
    - 成员（方法、字段、属性、事件、嵌套的类型）。
- 特性。
    - 修饰类型和成员的其他说明性元素。

元数据存储在 .NET 可迁移可执行文件 (PE) 文件的一个部分中，而 Microsoft 中间语言 (MSIL) 则存储在 PE 文件的另一部分中。 文件的元数据部分包含一系列的表和堆数据结构。 MSIL 部分包含 MSIL 和引用 PE 文件元数据部分的元数据标记。 例如，使用 MSIL 反汇编程序 (Ildasm.exe) 等工具查看代码的 MSIL 时，可能会遇到元数据标记。

每个元数据表都保留有关程序元素的信息。 例如，一个元数据表说明代码中的类，另一个元数据表说明字段等。 如果你的代码中有 10 个类，类表将有 10 行，每行一类。 元数据表引用其他的表和堆。 例如，类的元数据表引用方法表。

元数据还以四种堆结构存储信息：字符串、Blob、用户字符串和 GUID。 所有用于对类型和成员进行命名的字符串都存储在字符串堆中。 例如，方法表不直接存储特定方法的名称，而是指向存储在字符串堆中的方法的名称。

### 元数据标记

元数据标记在 PE 文件的 MSIL 部分中唯一确定每个元数据表的每一行。 元数据标记在概念上和指针相似，永久驻留在 MSIL 中，引用特定的元数据表。

要更好地理解元数据和它在公共语言运行时中的作用，构造一个简单的程序并说明元数据如何影响它的运行时情况可能很有帮助。 下面的代码示例显示名为 MyApp 的类中的两种方法。 Main 方法是程序入口点，而 Add 方法只返回两个整数参数的和。

```cpp
using System;
public class MyApp
{
   public static int Main()
   {
      int ValueOne = 10;
      int ValueTwo = 20;
      Console.WriteLine("The Value is: {0}", Add(ValueOne, ValueTwo));
      return 0;
   }
   public static int Add(int One, int Two)
   {
      return (One + Two);
   }
}
```

当代码运行时，运行时将模块加载到内存并向元数据咨询该类的信息。 加载后，运行时对方法的 Microsoft 中间语言 (MSIL) 流执行广泛的分析，将其转换为快速本机指令。 运行时根据需要使用实时 (JIT) 编译器将 MSIL 指令转换为本机代码，每次转换一个方法。

下面的示例显示了从以前代码的 `Main` 功能生成的部分 MSIL。 可使用 MSIL 反汇编程序 (Ildasm.exe) 从任何 .NET 应用程序中查看 MSIL 和元数据。

```cpp
.entrypoint
.maxstack  3
.locals ([0] int32 ValueOne,
         [1] int32 ValueTwo,
         [2] int32 V_2,
         [3] int32 V_3)
IL_0000:  ldc.i4.s   10
IL_0002:  stloc.0
IL_0003:  ldc.i4.s   20
IL_0005:  stloc.1
IL_0006:  ldstr      "The Value is: {0}"
IL_000b:  ldloc.0
IL_000c:  ldloc.1
IL_000d:  call int32 ConsoleApplication.MyApp::Add(int32,int32) /* 06000003 */
```

JIT 编译器读取整个方法的 MSIL，对其进行彻底地分析，然后为该方法生成有效的本机指令。 在 IL_000d 遇到 Add 方法 (/* 06000003 */) 的元数据标记，运行时使用该标记参考 MethodDef 表的第三行 。

下表显示了说明 方法的元数据标记所引用的 MethodDefAdd 表的一部分。 虽然程序集中存在其他元数据表并具有它们自己唯一的值，但这里只讨论该表。

![CLR%20%E5%85%AC%E5%85%B1%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E6%97%B6%20046cf021c5064abab630b4623ed67a8e/Untitled.png](CLR%20%E5%85%AC%E5%85%B1%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E6%97%B6%20046cf021c5064abab630b4623ed67a8e/Untitled.png)

该表的每一列都包含有关代码的重要信息。 RVA 列允许运行时计算定义此方法的 MSIL 的起始内存地址。 ImplFlags 和 Flags 列包含说明该方法的位屏蔽（例如，该方法是公共的还是私有的）。 Name 列对来自字符串堆的方法的名称进行了索引。 Signature 列对在 Blob 堆中的方法签名的定义进行了索引。

运行时在第三行的 RVA 列计算所需的偏移量地址并将该地址返回到 JIT 编译器，然后，JIT 编译器进入新地址。 JIT 编译器继续在新地址处理 MSIL，直到它遇到另一个元数据标记，之后，重复该过程。

使用元数据，运行时可以访问加载代码并将其处理为本机指令所需的所有信息。 以这种方式，元数据使自描述文件、常规类型系统和跨语言继承成为可能。