# C++ 内存对齐

### 让我们从一个例子开始

内存对齐是编译器为了便于 CPU 快速访问而采用的一项技术

我们先从一个例子开始，对下面的类 (或者结构体)：

```cpp
class node
{
	char c;
	int i;
	short s;
}no;
```

sizeof(no) 的值是多少呢，如果你的回答是 7(1+4+2)，那么你应该认真阅读下面的内容。可以在编译器上试试，输出的结果是 12，这就是内存对齐的结果。

### 为什么要进行内存对齐？

尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度.

现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。

假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作.

现在有了内存对齐的，int类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。

编译器一般按照几个字节对齐呢？本文中两个编译器**默认按照类中最大类型长度来对齐**，我们也可以使用语句 #pragma pack(i)(i = 1,2,4,8,16) 来设置对齐字节数目，vs 还可以在项目属性 - 配置属性 - c/c++- 代码生成 - 结构成员对齐设置。

### 对齐规则

每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。本文中两个编译器**默认按照类中最大类型长度来对齐.**

有效对其值 n：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。

- 如果设置了内存对齐为 i 字节，类中最大成员对齐字节数为 j，那么**整体对齐字节 n = min(i, j)** （某个成员的对齐字节数定义：如果该成员是 c++ 自带类型如 int、char、double 等，那么其对齐字节数 = 该类型在内存中所占的字节数；如果该成员是自定义类型如某个 class 或者 struct，那个它的对齐字节数 = 该类型内最大的成员对齐字节数）
- 每个成员对齐规则：类中第一个数据成员放在 offset 为 0 的位置；对于其他的数据成员（假设该数据成员对齐字节数为 k），他们放置的起始位置 **offset 应该是 min(k, n) (整体对齐字节数和自己的字节数之间的最小值)的整数倍**
- 整体对齐规则：最后整个类的大小应该是 n 的整数倍（整个类的大小与整体对齐字节数对齐）
- 当设置的对齐字节数大于类中最大成员对齐字节数时，这个设置实际上不产生任何效果（实例 2）；当设置对齐字节数为 1 时，类的大小就是简单的把所有成员大小相加

### 实例说话

- （没有指定对齐字节，则 n = 最大成员（int i）的大小 4）

```cpp
class A
{
	char c;   // 放在位置 0，位置区间 [0]
	int i;      //4 = n, 那么放置起始位置应该是 4 的倍数，即 4，位置区间为 [4~7]
	short s; //2 <n，那么放置起始位置应该是 2 的倍数，即 8，位置区间为 [8~9]
};
```

此时成员共占用 [0~9]10 个字节，还要整体对齐，大小应该是 4 的倍数，即 12

- （假设指定对齐字节为 8，那么 n = min(8,4) = 4）

```cpp
class B
{
	int i; // 放在位置 0，位置区间 [0~3]
	char c; //1 <n, 那么放置起始位置应该是 1 的倍数，即 4，位置区间为 [4]
	short s; //2 <n，那么放置起始位置应该是 2 的倍数，即 6，位置区间为 [6~7]
};
```

成员共占据 [0~7]8 个字节，刚好是 4 的倍数，因此大小是 8

- （假设指定对齐字节是 2，则 n = min(2,4) = 2）

```cpp
class C
{
	char c; // 放在位置 0，位置区间 [0]
	int i; //4 > n, 那么放置起始位置应该是 2 的倍数，即 2，位置区间为 [2~5]
	short s; //2 = n，那么放置起始位置应该是 2 的倍数，即 6，位置区间为 [6~7]
};
```

成员共占据 [0~7]8 个字节，刚好是 4 的倍数，因此大小是 8

- （按照默认设置）

```cpp
class D
{
	char c;
	int i;
	short s; 
};
```

由实例 1 可知，默认对齐情况下，temp 的大小是 12，temp 的对齐字节数是：三个成员取最大的，即为 4；对于 node，n = 其三个成员对齐字节数取最大，即等于 t 的对齐字节数，也就是 4。

```cpp
class E
{
	char c; // 放在位置 0，位置区间 [0]
	temp t; //4 temp 的对齐字节数=n,那么放置起始位置应该是4的倍数,即 4,位置区间为 [4~15]
	short s; //2 <n，那么放置起始位置应该是 2 的倍数，即 16，位置区间为 [16~17]
};
```

此时成员共占用 [0~17]18 个字节，还要整体对齐，大小应该是 4 的倍数，因此大小是 20

- （默然设置）

对于 node，n = 其三个成员对齐字节数取最大，即等于 d 的对齐字节数，也就是 8。

```cpp
class F
{
	temp t; // 放在位置 0，位置区间 [0~11]
	double d; //8 temp的对齐字节数= n,那么放置起始位置应该是 8 的倍数,即16,位置区间为[16~23]
	short s; //2 <n，那么放置起始位置应该是 2 的倍数，即 24，位置区间为 [24~25]
};
```

此时成员共占用 [0~25]26 个字节，还要整体对齐，大小应该是 8 的倍数，因此大小是 32.

### 类继承时的内存对齐

考虑如下类

```cpp
class A
{
		int i;
		char c1;
};
class B : public A
{
		char c2;
};
class C : public B
{
		char c3;
};
```

sizeof(C) 结果是多少呢，gcc 和 vs 给出了不同的结果，分别是 8、16

gcc 中：C 相当于把所有成员 i、c1、c2、c3 当作是在一个 class 内部，(先继承后对齐)

vs 中：对于 A，对齐后其大小是 8；对于 B，c2 加上对齐后的 A 的大小是 9，对齐后就是 12；对于 C，c3 加上对齐后的 B 大小是 13，再对齐就是 16 (先对齐后继承)