# 编译器(JIT&AOT)与解释器

## 什么是JIT&AOT？

**JIT，即 Just-in-time,** 动态 (即时) 编译，其最显著的特征是代码的编译过程发生在程序的执行期间，而非执行之前。**AOT，Ahead Of Time**，指运行前编译，常见的比如：使用 Clang 对 C/C++ 代码进行编译即为AOT典型的一个例子。

### JIT优缺点

优点：

- 可以根据当前硬件情况实时编译生成最优机器指令
- 可以根据当前程序的运行情况生成最优的机器指令序列
- 当程序需要支持动态链接时，只能使用 JIT
- 可以根据进程中内存的实际情况调整代码，使内存能够更充分的利用

缺点：

- 编译需要占用运行时资源，会导致进程卡顿
- 由于编译时间需要占用运行时间，对于某些代码的编译优化不能完全支持，需要在程序流畅和编译时间之间做权衡
- 在编译准备和识别频繁使用的方法需要占用时间，使得初始编译不能达到最高性能

### AOT优缺点

优点：

- 在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗
- 可以在程序运行初期就达到最高性能
- 可以显著的加快程序的启动

缺点：

- 在程序运行前编译会使程序安装的时间增加
- 将提前编译的内容保存会占用更多的空间

## JIT详解

JIT是“Just In Time”的首字母缩写。每当一个程序在运行时创建并运行一些新的可执行代码，而这些代码在存储于磁盘上时不属于该程序的一部分，它就是一个JIT。实际上JIT技术分为两个不同的阶段时更容易解释：

- 阶段一：在程序运行时创建机器代码
- 阶段二：在程序运行时也执行该机器代码

### 运行时创建机器代码

对于运行时创建机器代码，这其实是一个JIT 99%的挑战所在，生成机器码的过程实际上与传统的AOT过程相似，即输入代码，输出机器码，而事实上JIT主要的挑战在于如何平衡“收益”与“支出”。传统的 JIT 编译器在实际动态生成机器码前，会首先对原始代码或其相应的 IL 中间代码进行一系列的分析（profiling）。通过这些分析过程，编译器能够找到可以通过 JIT 编译进行性能优化的“关键代码路径”。而这里的取舍重点在于：对这些代码进行运行时优化而得到的性能提升收益，需要高于进行优化时所产生的性能开销。

另外需要注意的是，通常的 JIT 编译器由于考虑到“**启动延迟**（startup time delay）”的问题，因此一般会结合**解释器**一起使用。JIT 编译器所进行的代码分析过程越精细、所实施的优化越多，其动态生成的机器代码质量也会越高，但随之而来的初始代码执行延迟也会越大。**而解释器的加入便可使代码的执行过程提前进行**。而在此期间，JIT 编译器也会同时对代码进行分析和优化，并在特定的时刻再将程序的执行流程从解释执行转换到执行其动态生成的优化机器码。因此，对于 JIT Compilation 技术本身而言，其实现方式需要取舍的一个重点是：在编译时间和希望生成的代码质量之间进行权衡。比如，JVM 便有着两种可以选择的 JIT 模式 —— client 与 server，其中前者会采用最小的编译和优化选项以最大程度降低启动延迟；而后者则会采用最大化的编译和优化策略，同时牺牲程序的启动时间。

### 在程序运行时也执行该机器代码

接下来便谈到了如何在运行时执行动态生成的机器代码，至于为什么不多聊聊“”重要的99%”？主要还是因为前面的知识处于一种“宏观上的简单，微观上的复杂”，对我来说能够获得的知识密度实在是有限，所以就让我们愉快地聊聊剩下的1%吧。

现代操作系统对于允许程序在运行时执行的操作可以说是非常挑剔。过去“海阔凭鱼跃，天高任鸟飞”的日子随着**保护模式**的出现而不复存在，保护模式使得操作系统通过各种权限的区分，对虚拟内存块的使用做出了限制。因此，在“普通”代码中，你可以在堆上动态创建新数据，但是你不能在没有操作系统明确允许的情况下从堆中运行其内容。

实际上，当我们获得阶段一输出的机器码后，将机器代码放入内存是容易的，但是如何让它获得可执行权限，然后运行它呢？

**（注：mmap 请看 [内存映射 mmap/system V](%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%20mmap%20system%20V%20525b256cfb2e457c86c5ac99d291aff7.md) ）**

假设对于下面的这个函数：

```csharp
long add4(long num) { return num + 4;}
```

JIT 如何在内存中动态地执行它：

```csharp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>

// Allocates RWX memory of given size and returns a pointer to it. On failure,
// prints out the error and returns NULL.
void* alloc_executable_memory(size_t size) {
  void* ptr = mmap(0, size,
                   PROT_READ | PROT_WRITE | PROT_EXEC,
                   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (ptr == (void*)-1) {
    perror("mmap");
    return NULL;
  }
  return ptr;
}

void emit_code_into_memory(unsigned char* m) {
  unsigned char code[] = {              // 实时编译出的func的机器码
    0x48, 0x89, 0xf8,                   // mov %rdi, %rax
    0x48, 0x83, 0xc0, 0x04,             // add $4, %rax
    0xc3                                // ret
  };
  memcpy(m, code, sizeof(code));
}

const size_t SIZE = 1024;
typedef long (*JittedFunc)(long);

// Allocates RWX memory directly.
void run_from_rwx() {
  void* m = alloc_executable_memory(SIZE);
  emit_code_into_memory(m);

  JittedFunc func = m;
  int result = func(2);
  printf("result = %d\n", result);
}
```

此代码执行的主要3个步骤是：

1. 使用mmap在堆上分配可读，可写和可执行的内存块。
2. 将获得的add4函数的汇编/机器代码复制到此内存块中。
3. 将该内存块首地址转换为函数指针，并通过调用这一函数指针来执行此内存块中的代码。

注：步骤3能发生是因为包含机器代码的内存块是可执行的，如果没有设置正确的权限，该调用将导致OS的运行时错误（很可能是segmentation fault）。如果我们通过对malloc的常规调用来分配内存块，则会发生这种情况，malloc分配可读写但不可执行的内存。而通过**mmap**来分配内存块，则可以自行设置该内存块的属性

### 安全问题

上面显示的代码其实有一个安全漏洞，那就是它所分配的RWX（可读，可写，可执行）大块内存，这种内存对于漏洞攻击者来说可是可以大展身手，兴风作浪的天堂。所以让我们对它更负责任，进行一些略微的修改：

```cpp
void* alloc_writable_memory(size_t size) {
	void* ptr= mmap(0, size,
	                PROT_READ| PROT_WRITE,
	                MAP_PRIVATE| MAP_ANONYMOUS,-1, 0);
	if (ptr== (void*)-1) 
	{
	   perror("mmap");
		 return NULL;
	}
	return ptr;
}

void emit_code_into_memory(unsigned char* m) {
  unsigned char code[] = {              // 实时编译出的func的机器码
    0x48, 0x89, 0xf8,                   // mov %rdi, %rax
    0x48, 0x83, 0xc0, 0x04,             // add $4, %rax
    0xc3                                // ret
  };
  memcpy(m, code, sizeof(code));
}

int make_memory_executable(void* m, size_t size) {
	if (mprotect(m, size, PROT_READ| PROT_EXEC)==-1) {
	  perror("mprotect");
		return-1;
	}
	return 0;
}

void emit_to_rw_run_from_rx() {
	void* m= alloc_writable_memory(SIZE);
  emit_code_into_memory(m);
  make_memory_executable(m, SIZE);
  JittedFunc func= m;
	int result= func(2);
  printf("result = %d\n", result);
}
```

内存块首先被分配了RW权限，因为我们需要将函数的机器代码写入该内存块。然后我们使用mprotect将块的权限从RW更改为RX，使其可执行但不再可写，所以最终效果是一样的，但是在我们的程序执行过程中，没有任何一个时间点，该内存块是同时可写的和可执行的。

这种技术几乎是真正的JIT引擎（例如LLVM和libjit）从内存中发出和运行可执行机器代码的方式，剩下的只是从其他东西合成机器代码的问题。**LLVM有一个完整的编译器，所以它实际上可以在运行时将C和C ++代码（通过LLVM IR）转换为机器码，然后执行它（在理解了LLVM后，对于JIT&AOT的关系理解会更进一步）**

**在看了对于编译器的介绍后，对于JIT与AOT的关系会有更好的理解 [GCC & LLVM/clang](GCC%20&%20LLVM%20clang%2083901fd070874283a1449ba4957090a8.md)** 

## 解释器与编译器

在前文，我们介绍了编译器分为前端与后端([GCC & LLVM/clang](GCC%20&%20LLVM%20clang%2083901fd070874283a1449ba4957090a8.md) )，也介绍了JIT&AOT两种编译器的策略，其主要的区别在与我们将代码的编译阶段是放在运行时还是运前。但这两种策略在实际上都是**以聚合的方式获取源代码**，再到中间代码到机器码的过程。而不是逐语句的获取源代码并运行的。所以，无论是JIT还是AOT都是编译器范畴内的策略。

所以，到底什么是解释器呢？实际上我们从前一句话便能一窥一二。所谓解释器即**获取源代码的组成部分，即每次获取一行源代码**后进行词法/语法/语义分析后直接执行的代码运行方式。

![%E7%BC%96%E8%AF%91%E5%99%A8(JIT&AOT)%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%20b736c805b8e74e9b920ddcc805b931da/Untitled.png](%E7%BC%96%E8%AF%91%E5%99%A8(JIT&AOT)%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%20b736c805b8e74e9b920ddcc805b931da/Untitled.png)

### 解释器与编译器的区别

[两者的区别](%E7%BC%96%E8%AF%91%E5%99%A8(JIT&AOT)%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%20b736c805b8e74e9b920ddcc805b931da/%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%2035b3587e5dec43d7ac619a314e4d1d6c.csv)

**让我们看看编译器和解释器之间的主要区别：**

1、编译器将一个程序作为一个整体进行翻译，而解释器则一条一条地翻译一个程序

2、在编译器的情况下生成中间代码或目标代码。而解释器不创建中间代码

3、编译器比解释器要快得多，因为编译器一次完成整个程序，而解释器则是依次编译每一行代码

4、由于要生成目标代码，编译器比解释器需要更多的内存

5、编译器同时显示所有错误，很难检测错误，而解释器则逐个显示每条语句的错误，更容易检测错误

6、在编译器中，当程序中出现错误时，它会停止翻译，并在删除错误后重新翻译整个程序。相反，当解释器中发生错误时，它会阻止其翻译，在删除错误后，翻译将继续

7、在编译器中，这个过程需要两个步骤，首先将源代码翻译成目标程序，然后执行。而在解释器中，这是一个一次性的过程，源代码在编译和执行的同时

8、编译器用于编程语言，如 C、c++、c#、Scala 等。另一个解释器用于 PHP、Ruby、Python 等语言。

**从表象意义上看，重点就在：**

**解释**：输入程序代码 -> 得到执行结果，从用户的角度看一步到位

**编译**：输入程序代码 -> 得到可执行代码

要得到执行结果还得再去执行可执行代码，从用户的角度看有 [一个单独的编译步骤] 和[一个单独的执行步骤]

注意：JIT 编译器自身并不混合解释和编译，它就是编译器。一个使用 JIT 编译器实现的执行引擎，为了达到外在表象是解释执行，需要先通过 JIT 编译器将输入的程序编译为可执行代码（这是 JIT 编译器的职责），然后去执行这代码（这不是 JIT 编译器自身的职责，而是调用它的执行引擎的职责）。

## 解释器与JIT(即时编译器)

在我们看前一节“解释器与编译器的区别”时，实际上是有一些歧义的地方的，原因就是实际上JIT有一部分性质是与上面的介绍有所出入的，而实际上也是这样，JIT介于AOT与解释器之间。而解释器与JIT之间的区别，我们可以通过 JVM 的模型来一窥究竟。(实际上我们日常在表述时，“解释器”这个概念与JIT有时候是模糊的，解释器既可以指一个表象，也可以指具体的实现方式；当它指的是表象时，它底下的具体实现既可以是一个真的解释器，也可以是一个 JIT 编译器，或者两者的混合)

[%E7%BC%96%E8%AF%91%E5%99%A8(JIT&AOT)%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%20b736c805b8e74e9b920ddcc805b931da/20160812104144969.jfif](%E7%BC%96%E8%AF%91%E5%99%A8(JIT&AOT)%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%20b736c805b8e74e9b920ddcc805b931da/20160812104144969.jfif)

在 jdk 1.0 时代，java 虚拟完全是解释执行的。那什么是解释执行呢？解释器（你可以理解为翻译器）每次读一代码，就将字节码起转换（翻译）为 JVM 可执行的指令，一直到最后，说白了边听边译。这样的结果显易见，效率低下，**更重要的是同样的代码每次都需要重新翻译**。这怎么能忍，必须要解决啊。

随着后面的发展，现在大多数的主流的 JVM 都包含即时编译器。那什么是即时编译器呢？所谓的即时编译器说白了就是将源代码直接生成符合本地物理机可识别的机器语言。还是拿 java 举例呗，JVM 在运行期间，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为 “热点代码”。  然后将这部分“热点代码”即时编译，转换为本地机器语言。当然，这个代码热度的判断相对复杂，不仅仅是某个方法调用的次数达到指定阀值，不同的场景有不同的策略，具体就不说了。即时编译器的好处在于可以对代码进行深度优化，同时提高效率 (只编译了一次，以后每次都会调用执行的速度大大提高)

即时编译器并不是虚拟机必须的部分，Java 虚拟机规范并没有规定 Java 虚拟机内必须要有即时编译器存在，更没有限定或指导即时编译器应该如何去实现。但是，即时编译器编译性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键的指标之一，它也是虚拟机中最核心且最能体现虚拟机技术水平的部分。

### 为什么许多JVM虚拟机使用解释器与编译器并存的架构？

尽管并不是所有的 Java 虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机（如 HotSpot），都同时包含解释器和编译器。解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大（如部分嵌入式系统中），可以使用解释器执行节约内存，反之可以使用编译执行来提升效率。此外，如果编译后出现 “罕见陷阱”，可以通过逆优化退回到解释执行。

![%E7%BC%96%E8%AF%91%E5%99%A8(JIT&AOT)%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%20b736c805b8e74e9b920ddcc805b931da/20160812102841736.png](%E7%BC%96%E8%AF%91%E5%99%A8(JIT&AOT)%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%20b736c805b8e74e9b920ddcc805b931da/20160812102841736.png)

![%E7%BC%96%E8%AF%91%E5%99%A8(JIT&AOT)%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%20b736c805b8e74e9b920ddcc805b931da/1849270-1f0616875a4f8cc8.png](%E7%BC%96%E8%AF%91%E5%99%A8(JIT&AOT)%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%20b736c805b8e74e9b920ddcc805b931da/1849270-1f0616875a4f8cc8.png)

### 为何 HotSpot 虚拟机要实现两个不同的即时编译器？

HotSpot 虚拟机中内置了两个即时编译器：Client Complier 和 Server Complier，简称为 C1、C2 编译器，分别用在客户端和服务端。目前主流的 HotSpot 虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。程序使用哪个编译器，取决于虚拟机运行的模式。HotSpot 虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用 “-client” 或“-server”参数去强制指定虚拟机运行在 Client 模式或 Server 模式。

用 Client Complier 获取更高的*编译速度*，用 Server Complier 来获取更好的*编译质量*。为什么提供多个即时编译器与为什么提供多个垃圾收集器类似，都是为了适应不同的应用场景。

### 哪些程序代码会被编译为本地代码？如何编译为本地代码？

程序中的代码只有是热点代码时，才会编译为本地代码，那么什么是*热点代码*呢？

要知道方法或一段代码是不是热点代码，是不是需要触发即时编译，需要进行 Hot Spot Detection（热点探测）。

目前主要的热点探测方式有以下两种：

（1）基于采样的热点探测

采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这个方法就是 “热点方法”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。

(2) 基于计数器的热点探测

采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是 “热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。

![%E7%BC%96%E8%AF%91%E5%99%A8(JIT&AOT)%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%20b736c805b8e74e9b920ddcc805b931da/v2-646c4a71a76bfa537befbdb1137eac5c_r.jpg](%E7%BC%96%E8%AF%91%E5%99%A8(JIT&AOT)%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%20b736c805b8e74e9b920ddcc805b931da/v2-646c4a71a76bfa537befbdb1137eac5c_r.jpg)