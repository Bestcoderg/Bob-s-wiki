# B+树&红黑树

## B+树优势

首先数据查询是经过两步的：第一:将索引页加载到缓存中,然后从缓存中找到数据页，第二:将数据页数据加载到缓存,然后将数据返回出去。

### B+树降低 IO次数

所以说为什么B+树能够降低IO次数？按B树和B+树来说, B+树的索引页中全部是都是索引,这样一个数据页中能存储很多的索引，降低了下一次去磁盘再拿索引页的可能性，从而降低了IO次数。相对来说B树由于节点上即存储了数据又存储了索引,这样我一个索引页上上有数据有索引,肯定效率低了. 这个B树就是一个多叉树而已了,

### B+树查询效率更加稳定

由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；

### B+树便于范围查询（最重要的原因，范围查找是数据库的常态）

B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低；不懂可以看看这篇解读-》[范围查找](https://zhuanlan.zhihu.com/p/54102723)

## 红黑树

### **为什么要设计红黑树？**

先说一下红黑树，红黑树有一个比较复杂的规则，红的结点balala怎么样，黑的结点balalal怎么样。大一大二学这些的时候，傻呵呵的想背课文一样背下来，当也不知道为什么要设计成这样。换一句话说，为什么平衡树和红黑树的区别是什么？为什么有了平衡树还要设计出来红黑树？

红黑树的规则：1）每个结点要么是红的，要么是黑的。2）根结点是黑的。3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。4）如果一个结点是红的，那么它的俩个儿子都是黑的。5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。

现在想想，我的理解是**平衡树（AVL）**更平衡，结构上更加直观，时间效能针对读取而言更高，**但是维护起来比较麻烦！！！**（插入和删除之后，都需要rebalance）。但是，红黑树通过它规则的设定，确保了插入和删除的最坏的时间复杂度是O(log N) 。

设计红黑树的目的，**就是解决平衡树的维护起来比较麻烦的问题，红黑树，读取略逊于AVL，维护强于AVL，每次插入和删除的平均旋转次数应该是远小于平衡树。**

小结一下：

一棵含有n个节点的红黑树的高度至多为2log(n+1)

能用平衡树的地方，就可以用红黑树。用红黑树之后，读取略逊于AVL，维护强于AVL。

### **红黑树 和 b+树的用途有什么区别？**

1. 红黑树多用在内部排序，即全放在内存中的，STL的map和set的内部实现就是红黑树。
2. B+树多用于外存上时，B+也被成为一个磁盘友好的数据结构。