# MyISAM&InnoDB

## 索引

官方介绍索引是帮助 MySQL 高效获取数据的数据结构。笔者理解索引相当于一本书的目录，通过目录就知道要的资料在哪里， 不用一页一页查阅找出需要的资料。以下是几种索引的称呼：

**唯一索引 (unique index)：**强调唯一，就是索引值必须唯一。

**主键：**主键就是唯一索引的一种，主键要求建表时指定，一般用 auto_increment 列，关键字是 primary key

**全文索引：**InnoDB 不支持，MyISAM 支持性能比较好，一般在 CHAR、VARCHAR 或 TEXT 列上创建。

**单列索引与多列索引：**索引可以是单列索引也可以是多列索引（也叫复合索引）。按照上面形式创建出来的索引是单列索引，现在先看看创建多列索引：

注意：INDEX(a, b, c)可以当做 a 或 (a, b) 的索引来使用，但不能当作 b、c 或 (b,c) 的索引来使用。这是一个最左前缀的 优化方法，在后面会有详细的介绍，你只要知道有这样两个概念。

**聚簇索引：**一种索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。 聚簇索引确定表中数据的物理顺序。Mysql 中 MyISAM 表是没有聚簇索引的，innodb 有（主键就是聚簇索引），聚簇索引在下面介绍 innodb 结构的时有详细介绍。

### B-Tree数据结构

首先B+Tree作为B-Tree的一种改进类型，也可以算作B-Tree。所以作为索引中最为常见的一种类型，B-Tree 索引大都采用的是 B+Tree 数据结构来存储数据（NDB 集群存储引擎内部实际上采用 T-Tree 结构存储这种索引）。B-Tree通常也意味着所有的值都是按顺序存储的。

这点从磁盘读写上给出解释，磁盘顺序读写时才能达到其宣传的数值 ，因为随机读写，机械磁盘需要旋转及寻道时间，哪怕是 ssd，随机读写也需要寻址时间；那么如果将索引 tree 构建的层数越低，使得 key 相近的数据都存在一起，伴随磁盘预读特性，能更进一步提高性能。

那么使用 B+Tree 的关键就是 Tree 层数低 (3-4 层)，有序的数据存储位置接近，结合磁盘顺序读写、OS 预读写特性，使得能很快定位到数据；而使用 RB-Tree 时 key 值相近的数据会存储的较远，导致效率低下。

## MyISAM 索引的实现

MyISAM 索引文件和数据文件是分离的，索引文件仅保存记录所在页的指针（物理位置），通过这些地址来读取页，进而读取被索引的行。下图是 MyISAM 的索引原理图：（为了简化，一个页内只存放了两条记录。）

![MyISAM&InnoDB%2067141e1caf064be9a19d2d5c7fef5d90/Untitled.png](MyISAM&InnoDB%2067141e1caf064be9a19d2d5c7fef5d90/Untitled.png)

上图所提供的示例表字段有 Col1（ID）、Col2(age)、Col3（name）三个，其中 Col1 为 Primary Key（主键），上图很好地说明了树中叶子保存的是对应行的物理位置。通过该值，存储引擎能顺利地进行回表查询，得到一行完整记录。同时，每个叶子页也保存了指向下一个叶子页的指针。从而方便叶子节点的范围遍历。

而对于二级索引，在 MyISAM 存储引擎中以与上图同样的方式实现，可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。（这点和InnoDB是不一样的）

## InnoDB 索引的实现

### 聚集索引

与 MyISAM 相同的一点是，InnoDB 也采用 B+Tree 这种数据结构来实现 B-Tree 索引。而很大的区别在于，InnoDB 存储引擎采用 “聚集索引” 的数据存储方式实现 B-Tree 索引，**所谓“聚集”，就是指数据行和相邻的键值紧凑地存储在一起**，注意 InnoDB 只能聚集一个叶子页（16K）的记录（即聚集索引满足一定的范围的记录），因此包含相邻键值的记录可能会相距甚远。

注意: innodb 来说

1: 主键索引 既存储索引值, 又在叶子中存储行的数据

2: 如果没有主键, 则会 Unique key 做主键

3: 如果没有 unique, 则系统生成一个内部的 rowid 做主键.

4: 像 innodb 中, 主键的索引结构中, 既存储了主键值, 又存储了行数据, 这种结构称为” 聚簇索引”

下图说明了 InnoDB 聚集索引的实现方式，同时也体现了一张 innoDB 表的结构，可以看到，InnoDB 中，主键索引和数据是一体的，没有分开。：

[https://img-blog.csdn.net/20180421144550724?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xKRlBIUA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70](https://img-blog.csdn.net/20180421144550724?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xKRlBIUA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

这种实现方式，给予了 InnoDB 按主键检索的超高性能。可以有目的性地选择聚集索引，比如一个邮件表，可以选择用户 ID 来聚集数据，这样只需要从磁盘读取较少并且连续的数据页就能获得某个 id 的用户全部的邮件，避免了读取分散页时所耗费的随机 I/O。

### 辅助索引

而对于辅助索引，**InnoDB 采用的方式是在叶子页中保存主键值，通过这个主键值来回表（上图）查询到一条完整记录，因此按辅助索引检索实际上进行了二次查询**，效率肯定是没有按照主键检索高的。（先查找一次辅助索引的B+Tree，再用主键查找一次主键的B+Tree）下图是辅助索引的实现方式：

[https://img-blog.csdn.net/20180421144601295?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xKRlBIUA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70](https://img-blog.csdn.net/20180421144601295?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xKRlBIUA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

由于每个辅助索引都包含主键索引，因此，为了减小辅助索引所占空间，我们通常希望 InnoDB 表中的主键索引尽量定义得小一些（值得一提的是，MySIAM 会使用前缀压缩技术使得索引变小，而 InnoDB 按照原数据格式进行存储。），并且希望 InnoDB 的主键是自增长的，因为如果主键并非自增长，插入时，由于写入时乱序的，会使得插入效率变低。

可以看出 InnoDB 辅助索引并没有保存相应的所有列数据，而是保存了主键的键值，这样做利弊也是很明显：在已有主键索引，避免数据冗余，同时在修改数据的时候只需修改辅助索引值。但辅助索引查找数据事要检索两次，先找到相应的主键索引值然后在去检索主键索引找到对应的数据。这也是网上很多 mysql 性能优化时提到的 “主键尽可能简短” 的原因，主键越长辅助索引也就越大，当然主键索引也越大。

### 回表的概念

回表就是通过辅助索引拿到主键`id`之后，要再去遍历聚集索引的`B+`树，这个过程就叫做回表。回表的操作更多的是`随机io`,`随机io`在性能上还是比较低下的，例如：

```
比如user表中有三个字段，a,b,c，给a和b建立联合索引idex_a_b（a,b）
			sql：select * from  user where a=1 and b=2;
			
（1）首先是用二级索引index_a_b来查询，速度会很快，得到了很多的主键id。（顺序IO）
（2）拿到主键id之后，这个主键id并不是顺序排列的，还要用主键去查询聚簇索引（随机io）
（3）当随机io很多，也就是拿到的主键id很多的时候，回表的代价是巨大的。
	所以最好是选用覆盖索引或者让where 之后的条件筛选更多的数据
```

### **关于 innoDB 中索引的使用**

了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了 InnoDB 的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在 InnoDB 中不是个好主意，因为 InnoDB 数据文件本身是一颗 B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持 B+Tree 的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

## 如何选择myisam&innoDB

myisam 的主键索引的叶子节点只存放数据在物理磁盘上的指针，其他次索引也是一样的；innodb 的主键索引的叶子节点下面直接存放数据，其他次索引的叶子节点指向主键 id；由此可以挖掘出一个问题，就是如果 Innodb 有大数据列，比如 varchar(300)，这种比较多的话，那么排序的时候用主键 id 排序会比较慢，因为 id 主键下面放着所有数据列，而 Myisam 就不需要扫描数据列，要解决这个问题的话可以再建一个和主键 id 一起的联合索引。

MyISAM 表索引在处理文本索引时更具优势，而 INNODB 表索引在其它类型上更具效率优势。比如全文索引一般在 CHAR、VARCHAR 或 TEXT 列上创建，MyISAM 表支持而 INNODB 表不支持，常见主要针对文本进行索引。同时 MySQL 高并发需要事务场景时，只能使用 INNODB 表。

因为 MyISAM 相对简单所以在效率上要优于 InnoDB. 如果系统读多，写少。对原子性要求低。那么 MyISAM 最好的选择。且 MyISAM 恢复速度快。可直接用备份覆盖恢复。

如果系统读少，写多的时候，尤其是并发写入高的时候。InnoDB 就是首选了。两种类型都有自己优缺点，选择那个完全要看自己的实际类弄。