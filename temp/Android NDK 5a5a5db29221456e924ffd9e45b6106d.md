# Android NDK

## 什么是 NDK ?

- **什么是NDK？**
    
    NDK 全称：**Native Development Kit** 。是 Android 中的一个开发工具包, 为我们提供 native 开发的环境。
    
- **NDK 可以干什么？**
    1. NDK 提供了一系列的工具，帮助开发者快速开发 C/C++的动态库，并能自动将 so 和 java 应用一起打包成 apk。这些工具对开发者的帮助是巨大的。
    2. NDK 集成了交叉编译器，并提供了相应的 mk 文件隔离 **CPU、平台、ABI** 等差异，开发人员只需要简单修改 mk 文件（指出 “哪些文件需要编译”、“编译特性要求” 等），就可以创建出 .so 动态链接库。
- **NDK 与 SDK 的关系**
    1. 在 SDK 中，我们使用 Java 来进行开发，而在 NDK 中，我们使用 C++ 来进行开发
    2. SDK 支持了 Android 开发中的大部分操作，如 UI 展示，用户与手机的交互等，主要是支持了 Android APP 开发的**基础功能**
    3. NDK 支持了一些复杂的，比较高级的操作，如音视频的解析，大量数据的运算，提高 Android 游戏的运行速度等，主要是 Android APP 的一些**高级功能**
    
    所以 **NDK 与 SDK 是并列关系，NDK 是 SDK 的有效补充**
    
    ![Untitled](Android%20NDK%205a5a5db29221456e924ffd9e45b6106d/Untitled.png)
    

## **我们为什么要使用 NDK ?**

1. **允许程序开发人员直接使用 C/C++ 源代码**，极大的提高了 Android 应用程序开发的灵活性
2. 跨平台应用移植、使用第三方库。如：许多第三方库只有 C/C++ 语言的版本，而 Android 应用程序需要使用现有的第三方库，如 FFmpeg、OpenCV 等，则必须使用 NDK
3. 采用 C++ 代码来处理性能要求高的操作，提高了 Android APP 的性能
4. 安全性高

从以上总结我们可以大致看出 NDK 主要用于 Android 直接调用 C/C++ 开发的第三方库。

在 Google 中搜索 “NDK”，很多“Android 终于可以使用 C++ 开发” 之类的标题，这是一种对 Android 平台编程方式的误解。其实，Android 平台从诞生起，就已经支持 C/C++ 开发。众所周知，**Android 的 SDK 基于 Java 实现**，这意味着基于 Android SDK 进行开发的第三方应用都必须使用 Java 语言。但这并不等同于 “第三方应用只能使用 Java”。在 Android SDK 首次发布时，**Google 就宣称其虚拟机 Dalvik 支持 JNI 编程方式，也就是第三方应用完全可以通过 JNI 调用自己的 C 动态库，即在 Android 平台上，“Java+C” 的编程方式是一直都可以实现的。**

但在 NDK 诞生之前，**在 Android SDK 文档里，找不到任何 JNI 方面的帮助。**即使第三方应用开发者使用 JNI 完成了自己的 C 动态链接库（so）开发，但是 so 如何和应用程序一起打包成 apk 并发布？这里面也存在技术障碍。所以，在 NDK 出来之前，我们将 **“Java+C” 的开发模式称之为灰色模式，即官方既不声明“支持这种方式”，也不声明“不支持这种方式”。NDK 的发布，使 “Java+C” 的开发方式终于转正，成为官方支持的开发方式。**

- **我们依旧不能使用纯 C 开发Android应用**
    
    NDK 的发布，许多人会误以为，类似于 Symbian、WM，在 Android 平台上终于可以使用纯 C/C++ 开发第三方应用了！其实不然，NDK 文档明确说明：it is not a good way。因为 NDK 并没有提供各种系统事件处理支持，也没有提供应用程序生命周期维护。此外，在本次发布的 NDK 中，应用程序 UI 方面的 API 也没有提供。至少目前来说，使用纯 C/C++ 开发一个完整应用的条件还不完备。
    

### 什么是 JNI ?

我们前面提到了，由于 Android 基于 java 开发，而 java 作为一门语言肯定需要考虑与其他语言的交互问题。**JNI (Java Native Interface，Java本地接口) 是一种编程框架，使得Java虚拟机中的Java程序可以调用本地应用/或库，也可以被其他程序调用**。 本地程序一般是用其它语言(C/C++或汇编语言等)编写的，并且被编译为基于本机硬件和操作系统的程序。

以上有两点值得注意：

- **JNI 是一种编程框架，是一个抽象的东西，而不是一种实现。或是说 NDK 就是 Android 官方对 JNI 的一种实现。**
- **JNI 是属于 java 层面的，而 NDK 是属于Andriod 的。相当于之前 Android 官方之前没有关于与C/C++交互的定义。所以大家通过 JNI 来与 java 交互来调用第三方库，而 NDK 是 Android 官方对于 JNI 的一种实现，更好地来调用第三方库。**

![Untitled](Android%20NDK%205a5a5db29221456e924ffd9e45b6106d/Untitled%201.png)

- **以下我们写一个最简单的通过 JNI 框架来调用C/C++第三方库的例子：**
    1. 首先我们写一个java程序调用三方库：注意我们声明 sayHello 为一个native 方法，表示这个函数不在java中。
        
        ```cpp
        // Hello.java
        public class Hello {
            static {
                System.loadLibrary("hello");
            }
            public native void sayHello();
            public static void main(String[] args) {
                new Hello().sayHello();
            }
        }
        ```
        
    2. 编译java程序生成 Hello.class ，再使用生成头文件命令 `javah Hello` 生成Hello.h：
    
    ```cpp
    // Hello.h
    /* DO NOT EDIT THIS FILE - it is machine generated */
    #include <jni.h>
    /* Header for class Hello */
    
    #ifndef _Included_Hello
    #define _Included_Hello
    #ifdef __cplusplus
    extern "C" {
    #endif
    /*
     * Class:     Hello
     * Method:    sayHello
     * Signature: ()V
     */
    JNIEXPORT void JNICALL Java_Hello_sayHello
      (JNIEnv *, jobject);
    
    #ifdef __cplusplus
    }
    #endif
    #endif
    ```
    
    我们可以看到这个头文件声明根据Java中的声明的native方法，生成了一个C函数的声明`JNIEXPORT void JNICALL Java_Hello_sayHello(JNIEnv *, jobject);` Java中的native方法到C函数的命名规则为：`Java_{package_and_classname}_{function_name}();`  所有方法以`Java_`开头，接着是包名和类名，以`_`替换`.`，最后是方法名。
    
    在Java中`sayHello`是没有参数的方法，但是在生成的C函数声明中有两个参数，它们是每个方法都会传递的参数，分别为：
    
    - `JNIEnv*`，指向JNI环境的指针，通过它可以使用JNI协议提供的接口（函数）。
    - `jobject`，指向`this`的指针，用于获取类相关的信息（变量、方法等）。
    
    对于`JNIEXPORT`和`JNICALL`两个宏，用于设置函数可见性，以及调用栈约定，这里可以忽略这两个宏。
    
    1. 实现 native 方法：在`hello.c`中来实现函数`Java_Hello_sayHello`
    
    ```
    #include "Hello.h"
    #include <jni.h>
    #include <stdio.h>
    
    JNIEXPORT void JNICALL Java_Hello_sayHello (JNIEnv *env, jobject obj) {
      printf("Hello JNI!\n");
    }
    ```
    
    ---
    

实际上java的实现方案与我们之前看到过的C#中的 P/Invoke 的形式，将C++ DLL中接口导出给 C# 的方式是非常相似的。不过不同的是 java需要先编写java文件，通过javah来生成导出的头文件然后在C++中实现导出的接口才可以调用。而MS的C++DLL接口导出是通过提供了 __declspec(export)接口导出的。具体可以看[C++ DLL 接口导出](C++%20DLL%20%E6%8E%A5%E5%8F%A3%E5%AF%BC%E5%87%BA%20d69330faabe445d4b3dc73007af4820f.md) 。

## NDK 提供了什么？

我们前面说过，NDK 是 JNI 的一种实现。而 JNI 支持了 Java 代码与 native 代码之间的相互调用。但Java 并不是直接调用的 C/C++ 代码，我们需要先将 C/C++ 先编译为 .so/.dll 动态链接库。我们注意到实际上编译的动态链接库由于目标平台不同，我们所需的编译出来的格式也是不同的。这就涉及到了以下的一些知识：

### CPU架构

Android 平台，其支持的设备型号繁多，单单就设备的核心 CPU 而言，都有三大类：**ARM、x86 和 MIPS**

- *ARM 主要应用于手机中，x86 主要应用于 PC 中（**因为 PC 是 x86 架构，所以 PC 上的手机模拟器需要 x86 的二进制文件）**

而在 **NDK r17** 中，有了大的变化：

**在 NDK r17 以后，NDK 不在支持`32位和64位 MIPS` 和`ARM v5(armeabi)`**所以现在 NDK 只支持`ARM`和`x86`，而`ARM`和`x86`又各自分为两种：

简单的来说:**ARM 和 x86 各分为 32 位和 64 位两种，所以现在 NDK 一共支持 4 种 CPU 架构**

即：ARM 32 位 ，ARM 64 位 ， x86 32 位 ，x86 64 位

### ABI : Application Binary Interface

我们上面说了，每个系统只能使用相对应的二进制文件，

**不同的 Android 设备使用不同的 CPU，而不同的 CPU 支持不同的指令集。CPU 与指令集的每种组合都有专属的应用二进制接口 (ABI)（这个可以理解为一种CPU与在此之上按某种指令集标准的具体实现将会是某些指令的具体实现版本，这个版本对应了一个ABI）**简而言之：而 **ABI 定义了二进制文件是怎么运行在对应的 CPU 中。**

上面我们已经知道了有四种CPU架构，其 ABI 也有四种，他们分别是：**armeabi-v7a，armeabi-v8a，x86，x86_64。**

| ABI | 对应的 CPU 架构 | 应用 |
| --- | --- | --- |
| armeabi-v7a | ARM 32 位 | 手机 |
| armeabi-v8a | ARM 64 位 | 手机 |
| X86 | X86 32 位 | PC |
| X86_64 | X86 64 位 | PC |

CPU 架构中 **64 位的 CPU 架构兼容 32 位的 ABI 和 64 位的 ABI，32 位的 CPU 架构只支持 32 位的 ABI。**

**ABI 即应用程序二进制接口（Application Binary Interface）**。**ABI 包含了应用程序在这个系统下运行时必须遵守的编程约定**。ABI总是包含一系列的系统调用和使用这些系统调用的方法，以及关于程序可以使用的内存地址和使用机器寄存器的规定。从一个应用程序的角度看，**ABI既是系统架构的一部分也是硬件体系结构的重点，因此只要违反二者之一的条件约束就会导致程序出现严重错误**

ABI 描述了应用程序和操作系统之间，一个应用和它的库之间，或者应用的组成部分之间的低接口。ABI涵盖了各种细节，如：

- 数据类型的大小、布局和对齐；
- 调用约定（控制着函数的参数如何传送以及如何接受返回值），例如，是所有的参数都通过栈传递，还是部分参数通过寄存器传递；哪个寄存器用于哪个函数参数；通过栈传递的第一个函数参数是最先push到栈上还是最后；
- 系统调用的编码和一个应用如何向操作系统进行系统调用；
- 以及在一个完整的操作系统ABI中，目标文件的二进制格式、程序库等等。

在很多情况下，链接器为了遵守 ABI 的约定需要做一些重要的工作。例如，ABI要求每个应用程序包含一个程序中各例程使用的静态数据的所有地址表，链接器通过收集所有链接到程序中的模块的地址信息来创建地址表。ABI经常影响链接器的是对标准过程调用的定义 。