# git的存储机制

这篇文章主要是继上一篇对DVCS系统的介绍而衍生的一篇对git存储机制的思考。我们现在知道git和Mercurial的区别之一是Mercurial改动后存储的是文件差异的文件，而git存储的是整个文件的快照。那么到底git的快照是怎样的形式呢？这篇文章将由git的快照衍生出git的存储机制的内容。

### 什么是快照？

首先，快照的”快“并不是相对于Mercurial所使用的基于差异的文件存储形式，Mercurial的形式显然存储的文件大小要小于git的储存方式的，但我认为所谓快照的”快“是相对于保存整个文件的方式而言的。那么git采用的这种只储存差异文件的形式显然是快了许多。

例如，某个git空间中有file A、file B，你对file B进行了修改，随后在你进行了一次commit之前，git已经准备好一份快照，这份快照中储存了当前工作空间中指向未修改文件file1的指针和已经修改的file2数据（即当前时刻工作空间的文件数据状态）当commit时就等于保存了一次快照。

### 快照如何进行？

git会读取当前工作空间的所有数据，进行数据预存，再重新调整。它会和上一次的快照版本的内容进行比较，对于没有改变的文件数据，**git会把当前预存中冗余文件的数据去除掉**，**改为保留指向上一个版本中该文件数据的指针，对于有差异的文件数据就会保留下来，最终再把数据完整保存下来，**这才算是执行了一次快照。

![git%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6%20954fd7d652f54655a38ca03795641bb1/Untitled.png](git%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6%20954fd7d652f54655a38ca03795641bb1/Untitled.png)

### git的储存机制的优势&劣势

Git保存的不是文件差异或者变化量，而只是一系列文件快照。也就是说，Git每次修改之后都是整个文件去保存。

有些版本管理工具如Mercurial只是保存每个版本之间的变化，**这种做法显然的好处是大部分情况下占用空间较小，同时很容易比较两个版本之间的差异**。另外，在工作中经常需要看某行代码的改动是哪个changeset中进行的（如使用hg blame），Mercurial在查看此类信息时效率很高。但其进行分支切换时总是需要从头开始进行完全的迭代操作，这是非常慢的。

Git的优势是快，天下武功唯快不破，所以Git最终能一统江湖，千秋万代。虽然Git的速度很快，但是随着版本的增多或者对于文件特别大的项目，Git会有点吃力。毕竟，存储了过多的文件快照，如同吸星大法一样，会有反噬作用。由于库的大小在迭代过程中不断膨胀，git除了rebase机制，整合分支，这是一种缩减库大小的好方法，但实际上是有一些违背git精神的，所以总是备受诟病。

![git%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6%20954fd7d652f54655a38ca03795641bb1/Untitled%201.png](git%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6%20954fd7d652f54655a38ca03795641bb1/Untitled%201.png)

总的来说，我认为git的设计是一种非常适合于开源项目开发的形式（Linus赛高！！！），git在切换分支时由于使用的是快照的存储形式，通过改变指针的指向就可以切换分支，所以有着很快的切换速度，而对于一个开发者众多、分支冗杂的开源库，对于切换分支的需求是很高的。

### git的分支介绍

什么是git的分支？git的分支我认为是一系列的文件快照的集合，一个分支对应了一个头指针，在迭代过程中不断形成文件快照，而一系列快照串联成为一个链表就形成了这个分支的内容。通过工作指针HEAD的移动在分支之间进行切换。

![git%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6%20954fd7d652f54655a38ca03795641bb1/Untitled%202.png](git%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6%20954fd7d652f54655a38ca03795641bb1/Untitled%202.png)

现在我们知道了git存储文件的方式是快照我们就可以理解为什么当我们建立新分支时分支指针指向的是同一个结点，由于分支只是一系列快照的集合并通过一个头指针寻找，所以当没有改变即没有新的文件快照生成时，建立分支不过是增加了一个头指针。

![git%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6%20954fd7d652f54655a38ca03795641bb1/Untitled%203.png](git%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6%20954fd7d652f54655a38ca03795641bb1/Untitled%203.png)

除此之外，我们在了解了git的存储是以快照为基础后，我们也可以更好的理解为什么分支合并时需要解决冲突了，是因为合并时如果出现冲突说明一个文件有两种改变的方式，那么一个文件有两个不同的快照且两者没有迭代关系，git就不知道应该储存那个快照，所以这时一定要解决产生冲突的地方，让快照能够统一。

在文章的开头，我们还提到了快照的存储形式，其中对于没有改变的文件快照中保留的是指向上一个有效版本的指针，这也解释了为什么我们在画git的分支图时使用的箭头是指向从前的结点而不是指向后面的结点。