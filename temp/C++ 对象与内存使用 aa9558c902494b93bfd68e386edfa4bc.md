# C++ 对象与内存使用

## 创建对象

```cpp
#include <iostream> 
using namespace std; 
class A 
{ 
private: 
    int n; 
public: 
    A(int m):n(m) 
    { } 
    ~A(){} 
}; 
int main() 
{ 
    A a(1);  //栈中分配 
    A b = A(1);  //栈中分配 
    A* c = new A(1);  //堆中分配 
　　delete c; 
    return 0; 
}
```

第一种和第二种没什么区别，一个隐式调用，一个显式调用，两者都是在进程虚拟地址空间中的**栈中分配内存**，而第三种使用了**new，在堆中分配了内存**，**而栈中内存的分配和释放是由系统管理，而堆中内存的分配和释放必须由程序员手动释放**。采用第三种方式时，必须注意一下几点问题：

1. new创建类对象需要指针接收，**一处初始化，多处使用**
2. **new创建类对象使用完需delete销毁**
3. new创建对象直接使用堆空间，而局部不用new定义类对象则使用栈空间
4. new对象指针用途广泛，比如作为函数返回值、函数参数等
5. **频繁调用场合并不适合new，就像new申请和释放内存一样**
6. 栈的大小远小于堆的大
7. 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率 比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在 堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会 分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多

## 深拷贝&浅拷贝

简单的来说，**浅拷贝**是增加了一个指针，指向原来已经存在的内存。而**深拷贝**是增加了一个指针，并新开辟了一块空间，并让指针指向这块新开辟的空间。

**浅拷贝**在多个对象指向一块空间的时候，释放一个空间会导致其他对象所使用的空间也被释放了，再次释放便会出现错误。

决定对象是浅拷贝还是深拷贝的主要是对象有没有写拷贝构造函数。

```cpp
#include <iostream>
#include "student.h"
int main()
{
         Student s1;
         Student s2(s1);//Student s2 = s1;//复制对象
         return 0;
}
```

```cpp
class Student
{
         private:
               int num;
               char *name;
         public:
                Student();
                ~Student();
}
```

```cpp
class Student
{
       private:
             int num;
             char *name;
      public:
              Student();//构造函数
              ~Student();//析构函数
              Student(const Student &s); //重要：拷贝构造函数，const防止对象被改变
};
```

拷贝构造函数：

```cpp
Student::Student(const Student &s)
{
         name = new char(20);  // 对于每一次对象的引用，我们都重新开辟内存空间
         memcpy(name, s.name, strlen(s.name));
         cout << "copy Student " << endl;
}
```

## 内存泄漏问题

**1. 在类的构造函数和析构函数中没有匹配的调用new和delete函数：**

两种情况下会出现这种内存泄露：一是在堆里创建了对象占用了内存，但是**没有显示地释放对象占用的内存**；二是在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存

**2. 没有正确地清除嵌套的对象指针**

**3. 在释放对象数组时在delete中没有使用方括号**

方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值并调用对象的析构函数，如果没有方括号，那么这个指针就被默认为只指向一个对象，对象数组中的其他对象的析构函数就不会被调用，结果造成了内存泄露。如果在方括号中间放了一个比对象数组大小还大的数字，那么编译器就会调用无效对象（内存溢出）的析构函数，会造成堆的奔溃。如果方括号中间的数字值比对象数组的大小小的话，编译器就不能调用足够多个析构函数，结果会造成内存泄露。

**释放单个对象、单个基本数据类型的变量或者是基本数据类型的数组不需要大小参数，释放定义了析构函数的对象数组才需要大小参数。**

**4. 指向对象的指针数组不等同于对象数组**

对象数组是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间

指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，**正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了。**

**5. 缺少拷贝构造函数**

两次释放相同的内存是一种错误的做法，同时可能会造成堆的奔溃。

**按值传递会调用（拷贝）构造函数，引用传递不会调用。**

在C++中，**如果没有定义拷贝构造函数，那么编译器就会调用默认的拷贝构造函数**，会逐个成员拷贝的方式来复制数据成员，如果是以逐个成员拷贝的方式来复制指针被定义为将一个变量的地址赋给另一个变量。这种隐式的指针复制结果就是两个对象拥有指向同一个动态分配的内存空间的指针。当释放第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间。而释放第二个对象的时候，它的析构函数会释放相同的内存，这样是错误的。

**所以，如果一个类里面有指针成员变量，要么必须显示的写拷贝构造函数和重载赋值运算符，要么禁用拷贝构造函数和重载赋值运算符**

**6. 缺少重载赋值运算符**

这种问题跟上述问题类似，也是逐个成员拷贝的方式复制对象，如果这个类的大小是可变的，那么结果就是造成内存泄露，如下图:(可以看到原本5000的内存区域没有被释放)

![C++%20%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%20aa9558c902494b93bfd68e386edfa4bc/Untitled.png](C++%20%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%20aa9558c902494b93bfd68e386edfa4bc/Untitled.png)

**7. 没有将基类的析构函数定义为虚函数**

当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露

### 野指针

1. 返回栈上对象的引用或者指针（也即返回局部对象的引用或者指针）。导致最后返回的是一个空引用或者空指针，因此变成野指针
2. 指针变量没有被初始化
3. 指针被free或者delete后，没有置为NULL, free和delete只是把指针所指向的内存给释放掉，并没有把指针本身干掉，此时指针指向的是“垃圾”内存。释放后的指针应该被置为NULL.
4. 指针操作超越了变量的作用范围，比如返回指向栈内存的指针就是野指针。