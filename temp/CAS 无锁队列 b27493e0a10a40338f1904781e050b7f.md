# CAS / 无锁队列

无锁队列是lock-free中最基本的数据结构，一般应用场景是资源分配，比如TimerId的分配，WorkerId的分配，上电内存初始块数的申请等等。

对于多线程用户来说，无锁队列的入队和出队操作是线程安全的，不用再加锁控制。

## CAS

`C A S（compareAndSwap）`也叫比较交换，是一种无锁原子算法，映射到操作系统就是一条`cmpxchg`硬件汇编指令（**保证原子性**），其作用是让`C P U`将内存值更新为新值，但是有个条件，内存值必须与期望值相同，并且`C A S`操作无需用户态与内核态切换，直接在用户态对内存进行读写操作（**意味着不会阻塞 / 线程上下文切换**）。

它包含`3`个参数`C A S（V，E，N）`，`V`表示待更新的内存值，`E`表示预期值，`N`表示新值，当 `V`值等于`E`值时，才会将`V`值更新成`N`值，如果`V`值和`E`值不等，不做更新，这就是一次`C A S`的操作。

![Untitled](CAS%20%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%20b27493e0a10a40338f1904781e050b7f/Untitled.png)

简单说，`C A S`需要你额外给出一个期望值，也就是你认为这个变量现在应该是什么样子的，如果变量不是你想象的那样，说明它已经被别人修改过了，你只需要重新读取，设置新期望值，再次尝试修改就好了。

### CAS 保证原子性

原子性是指一个或者多个操作在`C P U`执行的过程中不被中断的特性，要么执行，要不执行，不能执行到一半（**不可被中断的一个或一系列操作**）

为什么 CAS 操作需要保证原子性呢？我们可以假设一下，如果 if(V==E) 这步操作与 V=N  这步操作之间被其他CPU抢占，并改变了 V 的值。那么在这种请款存在的情况下我们就无法保证CAS操作是安全的。

为了保证`C A S`的原子性，`C P U`提供了下面两种方式

- **总线锁定**

总线（`B U S`）是计算机组件间的传输数据方式，也就是说`C P U`与其他组件连接传输数据，就是靠总线完成的，比如`C P U`对内存的读写。

![Untitled](CAS%20%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%20b27493e0a10a40338f1904781e050b7f/Untitled%201.png)

**总线锁定**是指`C P U`使用了总线锁，所谓总线锁就是使用`C P U`提供的`LOCK#`信号，当`C P U`在总线上输出`LOCK#`信号时，其他`C P U`的总线请求将被阻塞。

![Untitled](CAS%20%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%20b27493e0a10a40338f1904781e050b7f/Untitled%202.png)

- **缓存锁定**

总线锁定方式虽然保证了原子性，但是在锁定期间，会导致大量阻塞，增加系统的性能开销，所以现代`C P U`为了提升性能，通过锁定范围缩小的思想设计出了缓存行 cache line 锁定（**缓存行是`C P U`高速缓存存储的最小单位**）。

所谓**缓存锁定**是指`C P U`对**缓存行**进行锁定，当缓存行中的共享变量回写到内存时，其他`C P U`会通过总线嗅探机制感知该共享变量是否发生变化，如果发生变化，让自己对应的共享变量缓存行失效，重新从内存读取最新的数据，缓存锁定是基于缓存一致性机制来实现的，因为缓存一致性机制会阻止两个以上`C P U`同时修改同一个共享变量（**现代`C P U`基本都支持和使用缓存锁定机制）**

### CAS 的问题

`C A S`和锁都解决了原子性问题，和锁相比没有阻塞、线程上下文你切换、死锁，所以`C A S`要比锁拥有更优越的性能，但是`C A S`同样存在缺点。

- **只能保证一个共享变量原子操作**

`C A S`只能针对一个共享变量使用，如果多个共享变量就只能使用锁了，当然如果你有办法把多个变量整成一个变量，利用`C A S`也不错，例如读写锁中`state`的高低位。

- **自旋时间太长**

当一个线程获取锁时失败，不进行阻塞挂起，而是间隔一段时间再次尝试获取，直到成功为止，这种循环获取的机制被称为自旋锁 (**`spinlock`**)。

自旋锁好处是，持有锁的线程在短时间内释放锁，那些等待竞争锁的线程就不需进入阻塞状态（**无需线程上下文切换 / 无需用户态与内核态切换**），它们只需要等一等（**自旋**），等到持有锁的线程释放锁之后即可获取，这样就避免了用户态和内核态的切换消耗。

自旋锁坏处显而易见，线程在长时间内持有锁，等待竞争锁的线程一直自旋，即 CPU 一直空转，资源浪费在毫无意义的地方，所以一般会限制自旋次数。

最后来说自旋锁的实现，实现自旋锁可以基于`C A S`实现，先定义`lockValue`对象默认值`1`，`1`代表锁资源空闲，`0`代表锁资源被占用

![Untitled](CAS%20%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%20b27493e0a10a40338f1904781e050b7f/Untitled%203.png)

从上图可以看出，只有`tryLock`成功的线程（**把`lockValue`更新为`0`**），才会执行代码块，其他线程个`tryLock`自旋等待`lockValue`被更新成`1`，`tryLock`成功的线程执行`unLock`（**把`lockValue`更新为`1`**），自旋的线程才会`tryLock`成功。

- **ABA 问题**

`C A S`需要检查待更新的内存值有没有被修改，如果没有则更新，但是存在这样一种情况，如果一个值原来是`A`，变成了`B`，然后又变成了`A`，在`C A S`检查的时候会发现没有被修改。

假设有两个线程，线程`1`读取到内存值`A`，线程`1`时间片用完，切换到线程`2`，线程`2`也读取到了内存值`A`，并把它修改为`B`值，然后再把`B`值还原到`A`值，简单说，修改次序是`A->B->A`，接着线程`1`恢复运行，它发现内存值还是`A`，然后执行`C A S`操作，这就是著名的`ABA`问题，但是好像又看不出什么问题。

只是简单的数据结构，确实不会有什么问题，如果是复杂的数据结构可能就会有问题了（**使用`AtomicReference`可以把`C A S`使用在对象上**），以链表数据结构为例，两个线程通过`C A S`去删除头节点，假设现在链表有`A->B`节点

![Untitled](CAS%20%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%20b27493e0a10a40338f1904781e050b7f/Untitled%204.png)

要解决`A B A`问题也非常简单，只要追加版本号即可，每次改变时加`1`，即`A —> B —> A`，变成`1A —> 2B —> 3A`，在`Java`中提供了`AtomicStampedRdference`可以实现这个方案（**面试只要问了`C A S`，就一定会问`ABA`，这块一定要搞明白**）。

## 无锁队列的列表实现

我们先来看一下进队列用CAS实现的方式：

```cpp
EnQueue(x) //进队列
{
    //准备新加入的结点数据
    q = new record();
    q->value = x;
    q->next = NULL;
 
    do {
        p = tail; //取链表尾指针的快照
    } while( CAS(p->next, NULL, q) != TRUE); //如果没有把结点链在尾指针上，再试
 
    CAS(tail, p, q); //置尾结点
}
```

在这种情况中，对于多线程情况，如果并发的几个线程中有一个线程成功，改变了tail指针，其他的线程的CAS就会返回false，这些线程将会retry。

这里有一个潜在的问题——如果T1线程在用CAS更新tail指针的之前，线程停掉或是挂掉了，那么其它线程就进入死循环了。下面是改良版的EnQueue()：

```cpp
EnQueue(x) //进队列改良版
{
    q = new record();
    q->value = x;
    q->next = NULL;
 
    p = tail;
    oldp = p
    do {
        while (p->next != NULL)
            p = p->next;
    } while( CAS(p->next, NULL, q) != TRUE); //如果没有把结点链在尾上，再试
 
    CAS(tail, oldp, q); //置尾结点
}
```

在这种实现方式中，对于多线程并发的情况每个线程会通过p指针fetch到链表尾，保证了并发线程能够同时间将自己的数据加入无锁队列。但是，在这种方式中，尾指针tail在并发状态下不一定指向链表尾，因为在并发状态下不能保证最后一句置尾结点的代码成功执行。当这句代码执行时tail便会恢复正常状态，重新指向链表尾部。而且，由于并发状态在整个执行过程中处于少数，所以tail一般能很快的恢复正常状态。

我们再来看一下出队的实现方式：

```cpp
DeQueue() //出队列
{
    do{
        p = head;
        if (p->next == NULL){
            return ERR_EMPTY_QUEUE;
        }
    while( CAS(head, p, p->next) != TRUE );
    return p->next->value;
}
```

我们可以看出，头元素为head->next，这就是说队列的第一个元素都是基于head->next而不是head。这样设计是有原因的。考虑一个边界条件：在队列只有一个元素条件下，如果head和tail指针指向同一个结点，这样入队操作和出队操作本身就需要互斥了。

![CAS%20%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%20b27493e0a10a40338f1904781e050b7f/Untitled%205.png](CAS%20%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%20b27493e0a10a40338f1904781e050b7f/Untitled%205.png)